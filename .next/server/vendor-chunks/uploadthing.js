"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/uploadthing";
exports.ids = ["vendor-chunks/uploadthing"];
exports.modules = {

/***/ "(ssr)/./node_modules/uploadthing/client/index.js":
/*!**************************************************!*\
  !*** ./node_modules/uploadthing/client/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   genUploader: () => (/* binding */ genUploader),\n/* harmony export */   generateClientDropzoneAccept: () => (/* reexport safe */ _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.generateClientDropzoneAccept),\n/* harmony export */   generateMimeTypes: () => (/* reexport safe */ _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.generateMimeTypes),\n/* harmony export */   generatePermittedFileTypes: () => (/* reexport safe */ _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.generatePermittedFileTypes),\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* harmony import */ var _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @uploadthing/shared */ \"(ssr)/./node_modules/@uploadthing/shared/dist/index.js\");\n\n\n\nvar version$1 = \"6.7.0\";\n\nconst maybeParseResponseXML = (maybeXml)=>{\n    const codeMatch = maybeXml.match(/<Code>(.*?)<\\/Code>/s);\n    const messageMatch = maybeXml.match(/<Message>(.*?)<\\/Message>/s);\n    const code = codeMatch?.[1];\n    const message = messageMatch?.[1];\n    if (!code || !message) return null;\n    return {\n        code: s3CodeToUploadThingCode[code] ?? DEFAULT_ERROR_CODE,\n        message\n    };\n};\n/**\n * Map S3 error codes to UploadThing error codes\n *\n * This is a subset of the S3 error codes, based on what seemed most likely to\n * occur in uploadthing. For a full list of S3 error codes, see:\n * https://docs.aws.amazon.com/AmazonS3/latest/API/ErrorResponses.html\n */ const DEFAULT_ERROR_CODE = \"UPLOAD_FAILED\";\nconst s3CodeToUploadThingCode = {\n    AccessDenied: \"FORBIDDEN\",\n    EntityTooSmall: \"TOO_SMALL\",\n    EntityTooLarge: \"TOO_LARGE\",\n    ExpiredToken: \"FORBIDDEN\",\n    IncorrectNumberOfFilesInPostRequest: \"TOO_MANY_FILES\",\n    InternalError: \"INTERNAL_SERVER_ERROR\",\n    KeyTooLongError: \"KEY_TOO_LONG\",\n    MaxMessageLengthExceeded: \"TOO_LARGE\"\n};\n\n/**\n * Used by client uploads where progress is needed.\n * Uses XMLHttpRequest.\n */ async function uploadPartWithProgress(opts, retryCount = 0) {\n    return new Promise((resolve, reject)=>{\n        const xhr = new XMLHttpRequest();\n        xhr.open(\"PUT\", opts.url, true);\n        xhr.setRequestHeader(\"Content-Type\", opts.fileType);\n        xhr.setRequestHeader(\"Content-Disposition\", (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.contentDisposition)(opts.contentDisposition, opts.fileName));\n        xhr.onload = async ()=>{\n            if (xhr.status >= 200 && xhr.status < 300) {\n                const etag = xhr.getResponseHeader(\"Etag\");\n                etag ? resolve(etag) : reject(\"NO ETAG\");\n            } else if (retryCount < opts.maxRetries) {\n                // Add a delay before retrying (exponential backoff can be used)\n                const delay = Math.pow(2, retryCount) * 1000;\n                await new Promise((res)=>setTimeout(res, delay));\n                await uploadPartWithProgress(opts, retryCount + 1); // Retry the request\n            } else {\n                reject(\"Max retries exceeded\");\n            }\n        };\n        let lastProgress = 0;\n        xhr.onerror = async ()=>{\n            lastProgress = 0;\n            if (retryCount < opts.maxRetries) {\n                // Add a delay before retrying (exponential backoff can be used)\n                const delay = Math.pow(2, retryCount) * 100;\n                await new Promise((res)=>setTimeout(res, delay));\n                await uploadPartWithProgress(opts, retryCount + 1); // Retry the request\n            } else {\n                reject(\"Max retries exceeded\");\n            }\n        };\n        xhr.upload.onprogress = (e)=>{\n            const delta = e.loaded - lastProgress;\n            lastProgress += delta;\n            opts.onProgress(delta);\n        };\n        xhr.send(opts.chunk);\n    });\n}\n\nconst createAPIRequestUrl = (config)=>{\n    const url = new URL(config.url);\n    const queryParams = new URLSearchParams(url.search);\n    queryParams.set(\"actionType\", config.actionType);\n    queryParams.set(\"slug\", config.slug);\n    url.search = queryParams.toString();\n    return url;\n};\n/**\n * Creates a \"client\" for reporting events to the UploadThing server via the user's API endpoint.\n * Events are handled in \"./handler.ts starting at L200\"\n */ const createUTReporter = (cfg)=>{\n    return async (type, payload)=>{\n        const url = createAPIRequestUrl({\n            url: cfg.url,\n            slug: cfg.endpoint,\n            actionType: type\n        });\n        let customHeaders = typeof cfg.headers === \"function\" ? cfg.headers() : cfg.headers;\n        if (customHeaders instanceof Promise) customHeaders = await customHeaders;\n        const response = await cfg.fetch(url, {\n            method: \"POST\",\n            body: JSON.stringify(payload),\n            headers: {\n                \"Content-Type\": \"application/json\",\n                \"x-uploadthing-package\": cfg.package,\n                \"x-uploadthing-version\": version$1,\n                ...customHeaders\n            }\n        });\n        switch(type){\n            case \"failure\":\n                {\n                    // why isn't this narrowed automatically?\n                    const p = payload;\n                    const parsed = maybeParseResponseXML(p.s3Error ?? \"\");\n                    if (parsed?.message) {\n                        throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                            code: parsed.code,\n                            message: parsed.message\n                        });\n                    } else {\n                        throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                            code: \"UPLOAD_FAILED\",\n                            message: `Failed to upload file ${p.fileName} to S3`,\n                            cause: p.s3Error\n                        });\n                    }\n                }\n        }\n        if (!response.ok) {\n            const error = await _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError.fromResponse(response);\n            throw error;\n        }\n        const jsonOrError = await (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.safeParseJSON)(response);\n        if (jsonOrError instanceof Error) {\n            throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"BAD_REQUEST\",\n                message: jsonOrError.message,\n                cause: response\n            });\n        }\n        return jsonOrError;\n    };\n};\n\n// Don't want to ship our logger to the client, keep size down\nconst version = version$1;\nconst uploadFilesInternal = async (endpoint, opts)=>{\n    // Fine to use global fetch in browser\n    const fetch = globalThis.fetch.bind(globalThis);\n    const reportEventToUT = createUTReporter({\n        endpoint: String(endpoint),\n        url: opts.url,\n        package: opts.package,\n        fetch,\n        headers: opts.headers\n    });\n    // Get presigned URL for S3 upload\n    const s3ConnectionRes = await reportEventToUT(\"upload\", {\n        input: \"input\" in opts ? opts.input : null,\n        files: opts.files.map((f)=>({\n                name: f.name,\n                size: f.size,\n                type: f.type\n            }))\n    });\n    if (!s3ConnectionRes || !Array.isArray(s3ConnectionRes)) {\n        throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n            code: \"BAD_REQUEST\",\n            message: \"No URL. How did you even get here?\",\n            cause: s3ConnectionRes\n        });\n    }\n    const fileUploadPromises = s3ConnectionRes.map(async (presigned)=>{\n        const file = opts.files.find((f)=>f.name === presigned.fileName);\n        if (!file) {\n            console.error(\"No file found for presigned URL\", presigned);\n            throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"NOT_FOUND\",\n                message: \"No file found for presigned URL\",\n                cause: `Expected file with name ${presigned.fileName} but got '${opts.files.join(\",\")}'`\n            });\n        }\n        opts.onUploadBegin?.({\n            file: file.name\n        });\n        if (\"urls\" in presigned) {\n            await uploadMultipart(file, presigned, {\n                reportEventToUT,\n                ...opts\n            });\n            // wait a bit as it's unsreasonable to expect the server to be done by now\n            await new Promise((r)=>setTimeout(r, 750));\n        } else {\n            await uploadPresignedPost(file, presigned, {\n                reportEventToUT,\n                ...opts\n            });\n        }\n        let serverData = null;\n        if (!opts.skipPolling) {\n            serverData = await (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.withExponentialBackoff)(async ()=>{\n                const res = await fetch(presigned.pollingUrl, {\n                    headers: {\n                        authorization: presigned.pollingJwt\n                    }\n                }).then((r)=>r.json());\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                return res.status === \"done\" ? res.callbackData : undefined;\n            });\n        }\n        return {\n            name: file.name,\n            size: file.size,\n            type: file.type,\n            key: presigned.key,\n            url: \"https://utfs.io/f/\" + presigned.key,\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            serverData: serverData,\n            customId: presigned.customId\n        };\n    });\n    return Promise.all(fileUploadPromises);\n};\nconst genUploader = (initOpts)=>{\n    return (endpoint, opts)=>// eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        uploadFilesInternal(endpoint, {\n            ...opts,\n            url: (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.resolveMaybeUrlArg)(initOpts?.url),\n            package: initOpts.package\n        });\n};\nasync function uploadMultipart(file, presigned, opts) {\n    let etags;\n    let uploadedBytes = 0;\n    try {\n        etags = await Promise.all(presigned.urls.map(async (url, index)=>{\n            const offset = presigned.chunkSize * index;\n            const end = Math.min(offset + presigned.chunkSize, file.size);\n            const chunk = file.slice(offset, end);\n            const etag = await uploadPartWithProgress({\n                url,\n                chunk: chunk,\n                contentDisposition: presigned.contentDisposition,\n                fileType: file.type,\n                fileName: file.name,\n                maxRetries: 10,\n                onProgress: (delta)=>{\n                    uploadedBytes += delta;\n                    const percent = uploadedBytes / file.size * 100;\n                    opts.onUploadProgress?.({\n                        file: file.name,\n                        progress: percent\n                    });\n                }\n            });\n            return {\n                tag: etag,\n                partNumber: index + 1\n            };\n        }));\n    } catch (error) {\n        await opts.reportEventToUT(\"failure\", {\n            fileKey: presigned.key,\n            uploadId: presigned.uploadId,\n            fileName: file.name,\n            s3Error: error.toString()\n        });\n        throw \"unreachable\"; // failure event will throw for us\n    }\n    // Tell the server that the upload is complete\n    await opts.reportEventToUT(\"multipart-complete\", {\n        uploadId: presigned.uploadId,\n        fileKey: presigned.key,\n        etags\n    }).catch((res)=>{\n        console.log(\"Failed to alert UT of upload completion\");\n        throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n            code: \"UPLOAD_FAILED\",\n            message: \"Failed to alert UT of upload completion\",\n            cause: res\n        });\n    });\n}\nasync function uploadPresignedPost(file, presigned, opts) {\n    const formData = new FormData();\n    Object.entries(presigned.fields).forEach(([k, v])=>formData.append(k, v));\n    formData.append(\"file\", file); // File data **MUST GO LAST**\n    const response = await new Promise((resolve, reject)=>{\n        const xhr = new XMLHttpRequest();\n        xhr.open(\"POST\", presigned.url);\n        xhr.setRequestHeader(\"Accept\", \"application/xml\");\n        xhr.upload.onprogress = (p)=>{\n            opts.onUploadProgress?.({\n                file: file.name,\n                progress: p.loaded / p.total * 100\n            });\n        };\n        xhr.onload = ()=>resolve({\n                status: xhr.status\n            });\n        xhr.onerror = (e)=>reject(e);\n        xhr.send(formData);\n    }).catch(async (error)=>{\n        await opts.reportEventToUT(\"failure\", {\n            fileKey: presigned.key,\n            uploadId: null,\n            fileName: file.name,\n            s3Error: error.toString()\n        });\n        throw \"unreachable\"; // failure event will throw for us\n    });\n    if (response.status > 299 || response.status < 200) {\n        await opts.reportEventToUT(\"failure\", {\n            fileKey: presigned.key,\n            uploadId: null,\n            fileName: file.name\n        });\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXBsb2FkdGhpbmcvY2xpZW50L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFzSTtBQUNwQjs7QUFFbEg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx1RUFBa0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxpRUFBZ0I7QUFDbEQ7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixzQkFBc0I7QUFDdEIsa0NBQWtDLGlFQUFnQjtBQUNsRDtBQUNBLDhEQUE4RCxZQUFZO0FBQzFFO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGlFQUFnQjtBQUNoRDtBQUNBO0FBQ0Esa0NBQWtDLGtFQUFhO0FBQy9DO0FBQ0Esc0JBQXNCLGlFQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixLQUFLO0FBQ0w7QUFDQSxrQkFBa0IsaUVBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlFQUFnQjtBQUN0QztBQUNBO0FBQ0Esa0RBQWtELG9CQUFvQixXQUFXLHFCQUFxQjtBQUN0RyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwyRUFBc0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix1RUFBa0I7QUFDbkM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGtCQUFrQixpRUFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNkJBQTZCO0FBQzdCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL3VwbG9hZHRoaW5nL2NsaWVudC9pbmRleC5qcz9hOTgwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNvbnRlbnREaXNwb3NpdGlvbiwgVXBsb2FkVGhpbmdFcnJvciwgc2FmZVBhcnNlSlNPTiwgcmVzb2x2ZU1heWJlVXJsQXJnLCB3aXRoRXhwb25lbnRpYWxCYWNrb2ZmIH0gZnJvbSAnQHVwbG9hZHRoaW5nL3NoYXJlZCc7XG5leHBvcnQgeyBnZW5lcmF0ZUNsaWVudERyb3B6b25lQWNjZXB0LCBnZW5lcmF0ZU1pbWVUeXBlcywgZ2VuZXJhdGVQZXJtaXR0ZWRGaWxlVHlwZXMgfSBmcm9tICdAdXBsb2FkdGhpbmcvc2hhcmVkJztcblxudmFyIHZlcnNpb24kMSA9IFwiNi43LjBcIjtcblxuY29uc3QgbWF5YmVQYXJzZVJlc3BvbnNlWE1MID0gKG1heWJlWG1sKT0+e1xuICAgIGNvbnN0IGNvZGVNYXRjaCA9IG1heWJlWG1sLm1hdGNoKC88Q29kZT4oLio/KTxcXC9Db2RlPi9zKTtcbiAgICBjb25zdCBtZXNzYWdlTWF0Y2ggPSBtYXliZVhtbC5tYXRjaCgvPE1lc3NhZ2U+KC4qPyk8XFwvTWVzc2FnZT4vcyk7XG4gICAgY29uc3QgY29kZSA9IGNvZGVNYXRjaD8uWzFdO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBtZXNzYWdlTWF0Y2g/LlsxXTtcbiAgICBpZiAoIWNvZGUgfHwgIW1lc3NhZ2UpIHJldHVybiBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvZGU6IHMzQ29kZVRvVXBsb2FkVGhpbmdDb2RlW2NvZGVdID8/IERFRkFVTFRfRVJST1JfQ09ERSxcbiAgICAgICAgbWVzc2FnZVxuICAgIH07XG59O1xuLyoqXG4gKiBNYXAgUzMgZXJyb3IgY29kZXMgdG8gVXBsb2FkVGhpbmcgZXJyb3IgY29kZXNcbiAqXG4gKiBUaGlzIGlzIGEgc3Vic2V0IG9mIHRoZSBTMyBlcnJvciBjb2RlcywgYmFzZWQgb24gd2hhdCBzZWVtZWQgbW9zdCBsaWtlbHkgdG9cbiAqIG9jY3VyIGluIHVwbG9hZHRoaW5nLiBGb3IgYSBmdWxsIGxpc3Qgb2YgUzMgZXJyb3IgY29kZXMsIHNlZTpcbiAqIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9BbWF6b25TMy9sYXRlc3QvQVBJL0Vycm9yUmVzcG9uc2VzLmh0bWxcbiAqLyBjb25zdCBERUZBVUxUX0VSUk9SX0NPREUgPSBcIlVQTE9BRF9GQUlMRURcIjtcbmNvbnN0IHMzQ29kZVRvVXBsb2FkVGhpbmdDb2RlID0ge1xuICAgIEFjY2Vzc0RlbmllZDogXCJGT1JCSURERU5cIixcbiAgICBFbnRpdHlUb29TbWFsbDogXCJUT09fU01BTExcIixcbiAgICBFbnRpdHlUb29MYXJnZTogXCJUT09fTEFSR0VcIixcbiAgICBFeHBpcmVkVG9rZW46IFwiRk9SQklEREVOXCIsXG4gICAgSW5jb3JyZWN0TnVtYmVyT2ZGaWxlc0luUG9zdFJlcXVlc3Q6IFwiVE9PX01BTllfRklMRVNcIixcbiAgICBJbnRlcm5hbEVycm9yOiBcIklOVEVSTkFMX1NFUlZFUl9FUlJPUlwiLFxuICAgIEtleVRvb0xvbmdFcnJvcjogXCJLRVlfVE9PX0xPTkdcIixcbiAgICBNYXhNZXNzYWdlTGVuZ3RoRXhjZWVkZWQ6IFwiVE9PX0xBUkdFXCJcbn07XG5cbi8qKlxuICogVXNlZCBieSBjbGllbnQgdXBsb2FkcyB3aGVyZSBwcm9ncmVzcyBpcyBuZWVkZWQuXG4gKiBVc2VzIFhNTEh0dHBSZXF1ZXN0LlxuICovIGFzeW5jIGZ1bmN0aW9uIHVwbG9hZFBhcnRXaXRoUHJvZ3Jlc3Mob3B0cywgcmV0cnlDb3VudCA9IDApIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCk9PntcbiAgICAgICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHhoci5vcGVuKFwiUFVUXCIsIG9wdHMudXJsLCB0cnVlKTtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LVR5cGVcIiwgb3B0cy5maWxlVHlwZSk7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC1EaXNwb3NpdGlvblwiLCBjb250ZW50RGlzcG9zaXRpb24ob3B0cy5jb250ZW50RGlzcG9zaXRpb24sIG9wdHMuZmlsZU5hbWUpKTtcbiAgICAgICAgeGhyLm9ubG9hZCA9IGFzeW5jICgpPT57XG4gICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV0YWcgPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJFdGFnXCIpO1xuICAgICAgICAgICAgICAgIGV0YWcgPyByZXNvbHZlKGV0YWcpIDogcmVqZWN0KFwiTk8gRVRBR1wiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmV0cnlDb3VudCA8IG9wdHMubWF4UmV0cmllcykge1xuICAgICAgICAgICAgICAgIC8vIEFkZCBhIGRlbGF5IGJlZm9yZSByZXRyeWluZyAoZXhwb25lbnRpYWwgYmFja29mZiBjYW4gYmUgdXNlZClcbiAgICAgICAgICAgICAgICBjb25zdCBkZWxheSA9IE1hdGgucG93KDIsIHJldHJ5Q291bnQpICogMTAwMDtcbiAgICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzKT0+c2V0VGltZW91dChyZXMsIGRlbGF5KSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdXBsb2FkUGFydFdpdGhQcm9ncmVzcyhvcHRzLCByZXRyeUNvdW50ICsgMSk7IC8vIFJldHJ5IHRoZSByZXF1ZXN0XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlamVjdChcIk1heCByZXRyaWVzIGV4Y2VlZGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBsZXQgbGFzdFByb2dyZXNzID0gMDtcbiAgICAgICAgeGhyLm9uZXJyb3IgPSBhc3luYyAoKT0+e1xuICAgICAgICAgICAgbGFzdFByb2dyZXNzID0gMDtcbiAgICAgICAgICAgIGlmIChyZXRyeUNvdW50IDwgb3B0cy5tYXhSZXRyaWVzKSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkIGEgZGVsYXkgYmVmb3JlIHJldHJ5aW5nIChleHBvbmVudGlhbCBiYWNrb2ZmIGNhbiBiZSB1c2VkKVxuICAgICAgICAgICAgICAgIGNvbnN0IGRlbGF5ID0gTWF0aC5wb3coMiwgcmV0cnlDb3VudCkgKiAxMDA7XG4gICAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlcyk9PnNldFRpbWVvdXQocmVzLCBkZWxheSkpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHVwbG9hZFBhcnRXaXRoUHJvZ3Jlc3Mob3B0cywgcmV0cnlDb3VudCArIDEpOyAvLyBSZXRyeSB0aGUgcmVxdWVzdFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWplY3QoXCJNYXggcmV0cmllcyBleGNlZWRlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgeGhyLnVwbG9hZC5vbnByb2dyZXNzID0gKGUpPT57XG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9IGUubG9hZGVkIC0gbGFzdFByb2dyZXNzO1xuICAgICAgICAgICAgbGFzdFByb2dyZXNzICs9IGRlbHRhO1xuICAgICAgICAgICAgb3B0cy5vblByb2dyZXNzKGRlbHRhKTtcbiAgICAgICAgfTtcbiAgICAgICAgeGhyLnNlbmQob3B0cy5jaHVuayk7XG4gICAgfSk7XG59XG5cbmNvbnN0IGNyZWF0ZUFQSVJlcXVlc3RVcmwgPSAoY29uZmlnKT0+e1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoY29uZmlnLnVybCk7XG4gICAgY29uc3QgcXVlcnlQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHVybC5zZWFyY2gpO1xuICAgIHF1ZXJ5UGFyYW1zLnNldChcImFjdGlvblR5cGVcIiwgY29uZmlnLmFjdGlvblR5cGUpO1xuICAgIHF1ZXJ5UGFyYW1zLnNldChcInNsdWdcIiwgY29uZmlnLnNsdWcpO1xuICAgIHVybC5zZWFyY2ggPSBxdWVyeVBhcmFtcy50b1N0cmluZygpO1xuICAgIHJldHVybiB1cmw7XG59O1xuLyoqXG4gKiBDcmVhdGVzIGEgXCJjbGllbnRcIiBmb3IgcmVwb3J0aW5nIGV2ZW50cyB0byB0aGUgVXBsb2FkVGhpbmcgc2VydmVyIHZpYSB0aGUgdXNlcidzIEFQSSBlbmRwb2ludC5cbiAqIEV2ZW50cyBhcmUgaGFuZGxlZCBpbiBcIi4vaGFuZGxlci50cyBzdGFydGluZyBhdCBMMjAwXCJcbiAqLyBjb25zdCBjcmVhdGVVVFJlcG9ydGVyID0gKGNmZyk9PntcbiAgICByZXR1cm4gYXN5bmMgKHR5cGUsIHBheWxvYWQpPT57XG4gICAgICAgIGNvbnN0IHVybCA9IGNyZWF0ZUFQSVJlcXVlc3RVcmwoe1xuICAgICAgICAgICAgdXJsOiBjZmcudXJsLFxuICAgICAgICAgICAgc2x1ZzogY2ZnLmVuZHBvaW50LFxuICAgICAgICAgICAgYWN0aW9uVHlwZTogdHlwZVxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGN1c3RvbUhlYWRlcnMgPSB0eXBlb2YgY2ZnLmhlYWRlcnMgPT09IFwiZnVuY3Rpb25cIiA/IGNmZy5oZWFkZXJzKCkgOiBjZmcuaGVhZGVycztcbiAgICAgICAgaWYgKGN1c3RvbUhlYWRlcnMgaW5zdGFuY2VvZiBQcm9taXNlKSBjdXN0b21IZWFkZXJzID0gYXdhaXQgY3VzdG9tSGVhZGVycztcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjZmcuZmV0Y2godXJsLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocGF5bG9hZCksXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgXCJ4LXVwbG9hZHRoaW5nLXBhY2thZ2VcIjogY2ZnLnBhY2thZ2UsXG4gICAgICAgICAgICAgICAgXCJ4LXVwbG9hZHRoaW5nLXZlcnNpb25cIjogdmVyc2lvbiQxLFxuICAgICAgICAgICAgICAgIC4uLmN1c3RvbUhlYWRlcnNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHN3aXRjaCh0eXBlKXtcbiAgICAgICAgICAgIGNhc2UgXCJmYWlsdXJlXCI6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAvLyB3aHkgaXNuJ3QgdGhpcyBuYXJyb3dlZCBhdXRvbWF0aWNhbGx5P1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwID0gcGF5bG9hZDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gbWF5YmVQYXJzZVJlc3BvbnNlWE1MKHAuczNFcnJvciA/PyBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlZD8ubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IHBhcnNlZC5jb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHBhcnNlZC5tZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIlVQTE9BRF9GQUlMRURcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgRmFpbGVkIHRvIHVwbG9hZCBmaWxlICR7cC5maWxlTmFtZX0gdG8gUzNgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdXNlOiBwLnMzRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gYXdhaXQgVXBsb2FkVGhpbmdFcnJvci5mcm9tUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QganNvbk9yRXJyb3IgPSBhd2FpdCBzYWZlUGFyc2VKU09OKHJlc3BvbnNlKTtcbiAgICAgICAgaWYgKGpzb25PckVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIkJBRF9SRVFVRVNUXCIsXG4gICAgICAgICAgICAgICAgbWVzc2FnZToganNvbk9yRXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgICAgICBjYXVzZTogcmVzcG9uc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqc29uT3JFcnJvcjtcbiAgICB9O1xufTtcblxuLy8gRG9uJ3Qgd2FudCB0byBzaGlwIG91ciBsb2dnZXIgdG8gdGhlIGNsaWVudCwga2VlcCBzaXplIGRvd25cbmNvbnN0IHZlcnNpb24gPSB2ZXJzaW9uJDE7XG5jb25zdCB1cGxvYWRGaWxlc0ludGVybmFsID0gYXN5bmMgKGVuZHBvaW50LCBvcHRzKT0+e1xuICAgIC8vIEZpbmUgdG8gdXNlIGdsb2JhbCBmZXRjaCBpbiBicm93c2VyXG4gICAgY29uc3QgZmV0Y2ggPSBnbG9iYWxUaGlzLmZldGNoLmJpbmQoZ2xvYmFsVGhpcyk7XG4gICAgY29uc3QgcmVwb3J0RXZlbnRUb1VUID0gY3JlYXRlVVRSZXBvcnRlcih7XG4gICAgICAgIGVuZHBvaW50OiBTdHJpbmcoZW5kcG9pbnQpLFxuICAgICAgICB1cmw6IG9wdHMudXJsLFxuICAgICAgICBwYWNrYWdlOiBvcHRzLnBhY2thZ2UsXG4gICAgICAgIGZldGNoLFxuICAgICAgICBoZWFkZXJzOiBvcHRzLmhlYWRlcnNcbiAgICB9KTtcbiAgICAvLyBHZXQgcHJlc2lnbmVkIFVSTCBmb3IgUzMgdXBsb2FkXG4gICAgY29uc3QgczNDb25uZWN0aW9uUmVzID0gYXdhaXQgcmVwb3J0RXZlbnRUb1VUKFwidXBsb2FkXCIsIHtcbiAgICAgICAgaW5wdXQ6IFwiaW5wdXRcIiBpbiBvcHRzID8gb3B0cy5pbnB1dCA6IG51bGwsXG4gICAgICAgIGZpbGVzOiBvcHRzLmZpbGVzLm1hcCgoZik9Pih7XG4gICAgICAgICAgICAgICAgbmFtZTogZi5uYW1lLFxuICAgICAgICAgICAgICAgIHNpemU6IGYuc2l6ZSxcbiAgICAgICAgICAgICAgICB0eXBlOiBmLnR5cGVcbiAgICAgICAgICAgIH0pKVxuICAgIH0pO1xuICAgIGlmICghczNDb25uZWN0aW9uUmVzIHx8ICFBcnJheS5pc0FycmF5KHMzQ29ubmVjdGlvblJlcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICAgICAgY29kZTogXCJCQURfUkVRVUVTVFwiLFxuICAgICAgICAgICAgbWVzc2FnZTogXCJObyBVUkwuIEhvdyBkaWQgeW91IGV2ZW4gZ2V0IGhlcmU/XCIsXG4gICAgICAgICAgICBjYXVzZTogczNDb25uZWN0aW9uUmVzXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBmaWxlVXBsb2FkUHJvbWlzZXMgPSBzM0Nvbm5lY3Rpb25SZXMubWFwKGFzeW5jIChwcmVzaWduZWQpPT57XG4gICAgICAgIGNvbnN0IGZpbGUgPSBvcHRzLmZpbGVzLmZpbmQoKGYpPT5mLm5hbWUgPT09IHByZXNpZ25lZC5maWxlTmFtZSk7XG4gICAgICAgIGlmICghZmlsZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIk5vIGZpbGUgZm91bmQgZm9yIHByZXNpZ25lZCBVUkxcIiwgcHJlc2lnbmVkKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIk5PVF9GT1VORFwiLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiTm8gZmlsZSBmb3VuZCBmb3IgcHJlc2lnbmVkIFVSTFwiLFxuICAgICAgICAgICAgICAgIGNhdXNlOiBgRXhwZWN0ZWQgZmlsZSB3aXRoIG5hbWUgJHtwcmVzaWduZWQuZmlsZU5hbWV9IGJ1dCBnb3QgJyR7b3B0cy5maWxlcy5qb2luKFwiLFwiKX0nYFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgb3B0cy5vblVwbG9hZEJlZ2luPy4oe1xuICAgICAgICAgICAgZmlsZTogZmlsZS5uYW1lXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoXCJ1cmxzXCIgaW4gcHJlc2lnbmVkKSB7XG4gICAgICAgICAgICBhd2FpdCB1cGxvYWRNdWx0aXBhcnQoZmlsZSwgcHJlc2lnbmVkLCB7XG4gICAgICAgICAgICAgICAgcmVwb3J0RXZlbnRUb1VULFxuICAgICAgICAgICAgICAgIC4uLm9wdHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gd2FpdCBhIGJpdCBhcyBpdCdzIHVuc3JlYXNvbmFibGUgdG8gZXhwZWN0IHRoZSBzZXJ2ZXIgdG8gYmUgZG9uZSBieSBub3dcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyKT0+c2V0VGltZW91dChyLCA3NTApKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IHVwbG9hZFByZXNpZ25lZFBvc3QoZmlsZSwgcHJlc2lnbmVkLCB7XG4gICAgICAgICAgICAgICAgcmVwb3J0RXZlbnRUb1VULFxuICAgICAgICAgICAgICAgIC4uLm9wdHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzZXJ2ZXJEYXRhID0gbnVsbDtcbiAgICAgICAgaWYgKCFvcHRzLnNraXBQb2xsaW5nKSB7XG4gICAgICAgICAgICBzZXJ2ZXJEYXRhID0gYXdhaXQgd2l0aEV4cG9uZW50aWFsQmFja29mZihhc3luYyAoKT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKHByZXNpZ25lZC5wb2xsaW5nVXJsLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1dGhvcml6YXRpb246IHByZXNpZ25lZC5wb2xsaW5nSnd0XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KS50aGVuKChyKT0+ci5qc29uKCkpO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVyblxuICAgICAgICAgICAgICAgIHJldHVybiByZXMuc3RhdHVzID09PSBcImRvbmVcIiA/IHJlcy5jYWxsYmFja0RhdGEgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogZmlsZS5uYW1lLFxuICAgICAgICAgICAgc2l6ZTogZmlsZS5zaXplLFxuICAgICAgICAgICAgdHlwZTogZmlsZS50eXBlLFxuICAgICAgICAgICAga2V5OiBwcmVzaWduZWQua2V5LFxuICAgICAgICAgICAgdXJsOiBcImh0dHBzOi8vdXRmcy5pby9mL1wiICsgcHJlc2lnbmVkLmtleSxcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgICAgIHNlcnZlckRhdGE6IHNlcnZlckRhdGEsXG4gICAgICAgICAgICBjdXN0b21JZDogcHJlc2lnbmVkLmN1c3RvbUlkXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKGZpbGVVcGxvYWRQcm9taXNlcyk7XG59O1xuY29uc3QgZ2VuVXBsb2FkZXIgPSAoaW5pdE9wdHMpPT57XG4gICAgcmV0dXJuIChlbmRwb2ludCwgb3B0cyk9Pi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50XG4gICAgICAgIHVwbG9hZEZpbGVzSW50ZXJuYWwoZW5kcG9pbnQsIHtcbiAgICAgICAgICAgIC4uLm9wdHMsXG4gICAgICAgICAgICB1cmw6IHJlc29sdmVNYXliZVVybEFyZyhpbml0T3B0cz8udXJsKSxcbiAgICAgICAgICAgIHBhY2thZ2U6IGluaXRPcHRzLnBhY2thZ2VcbiAgICAgICAgfSk7XG59O1xuYXN5bmMgZnVuY3Rpb24gdXBsb2FkTXVsdGlwYXJ0KGZpbGUsIHByZXNpZ25lZCwgb3B0cykge1xuICAgIGxldCBldGFncztcbiAgICBsZXQgdXBsb2FkZWRCeXRlcyA9IDA7XG4gICAgdHJ5IHtcbiAgICAgICAgZXRhZ3MgPSBhd2FpdCBQcm9taXNlLmFsbChwcmVzaWduZWQudXJscy5tYXAoYXN5bmMgKHVybCwgaW5kZXgpPT57XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBwcmVzaWduZWQuY2h1bmtTaXplICogaW5kZXg7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSBNYXRoLm1pbihvZmZzZXQgKyBwcmVzaWduZWQuY2h1bmtTaXplLCBmaWxlLnNpemUpO1xuICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBmaWxlLnNsaWNlKG9mZnNldCwgZW5kKTtcbiAgICAgICAgICAgIGNvbnN0IGV0YWcgPSBhd2FpdCB1cGxvYWRQYXJ0V2l0aFByb2dyZXNzKHtcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgY2h1bms6IGNodW5rLFxuICAgICAgICAgICAgICAgIGNvbnRlbnREaXNwb3NpdGlvbjogcHJlc2lnbmVkLmNvbnRlbnREaXNwb3NpdGlvbixcbiAgICAgICAgICAgICAgICBmaWxlVHlwZTogZmlsZS50eXBlLFxuICAgICAgICAgICAgICAgIGZpbGVOYW1lOiBmaWxlLm5hbWUsXG4gICAgICAgICAgICAgICAgbWF4UmV0cmllczogMTAsXG4gICAgICAgICAgICAgICAgb25Qcm9ncmVzczogKGRlbHRhKT0+e1xuICAgICAgICAgICAgICAgICAgICB1cGxvYWRlZEJ5dGVzICs9IGRlbHRhO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwZXJjZW50ID0gdXBsb2FkZWRCeXRlcyAvIGZpbGUuc2l6ZSAqIDEwMDtcbiAgICAgICAgICAgICAgICAgICAgb3B0cy5vblVwbG9hZFByb2dyZXNzPy4oe1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZTogZmlsZS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3M6IHBlcmNlbnRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRhZzogZXRhZyxcbiAgICAgICAgICAgICAgICBwYXJ0TnVtYmVyOiBpbmRleCArIDFcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBhd2FpdCBvcHRzLnJlcG9ydEV2ZW50VG9VVChcImZhaWx1cmVcIiwge1xuICAgICAgICAgICAgZmlsZUtleTogcHJlc2lnbmVkLmtleSxcbiAgICAgICAgICAgIHVwbG9hZElkOiBwcmVzaWduZWQudXBsb2FkSWQsXG4gICAgICAgICAgICBmaWxlTmFtZTogZmlsZS5uYW1lLFxuICAgICAgICAgICAgczNFcnJvcjogZXJyb3IudG9TdHJpbmcoKVxuICAgICAgICB9KTtcbiAgICAgICAgdGhyb3cgXCJ1bnJlYWNoYWJsZVwiOyAvLyBmYWlsdXJlIGV2ZW50IHdpbGwgdGhyb3cgZm9yIHVzXG4gICAgfVxuICAgIC8vIFRlbGwgdGhlIHNlcnZlciB0aGF0IHRoZSB1cGxvYWQgaXMgY29tcGxldGVcbiAgICBhd2FpdCBvcHRzLnJlcG9ydEV2ZW50VG9VVChcIm11bHRpcGFydC1jb21wbGV0ZVwiLCB7XG4gICAgICAgIHVwbG9hZElkOiBwcmVzaWduZWQudXBsb2FkSWQsXG4gICAgICAgIGZpbGVLZXk6IHByZXNpZ25lZC5rZXksXG4gICAgICAgIGV0YWdzXG4gICAgfSkuY2F0Y2goKHJlcyk9PntcbiAgICAgICAgY29uc29sZS5sb2coXCJGYWlsZWQgdG8gYWxlcnQgVVQgb2YgdXBsb2FkIGNvbXBsZXRpb25cIik7XG4gICAgICAgIHRocm93IG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgIGNvZGU6IFwiVVBMT0FEX0ZBSUxFRFwiLFxuICAgICAgICAgICAgbWVzc2FnZTogXCJGYWlsZWQgdG8gYWxlcnQgVVQgb2YgdXBsb2FkIGNvbXBsZXRpb25cIixcbiAgICAgICAgICAgIGNhdXNlOiByZXNcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiB1cGxvYWRQcmVzaWduZWRQb3N0KGZpbGUsIHByZXNpZ25lZCwgb3B0cykge1xuICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgT2JqZWN0LmVudHJpZXMocHJlc2lnbmVkLmZpZWxkcykuZm9yRWFjaCgoW2ssIHZdKT0+Zm9ybURhdGEuYXBwZW5kKGssIHYpKTtcbiAgICBmb3JtRGF0YS5hcHBlbmQoXCJmaWxlXCIsIGZpbGUpOyAvLyBGaWxlIGRhdGEgKipNVVNUIEdPIExBU1QqKlxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCk9PntcbiAgICAgICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHhoci5vcGVuKFwiUE9TVFwiLCBwcmVzaWduZWQudXJsKTtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJBY2NlcHRcIiwgXCJhcHBsaWNhdGlvbi94bWxcIik7XG4gICAgICAgIHhoci51cGxvYWQub25wcm9ncmVzcyA9IChwKT0+e1xuICAgICAgICAgICAgb3B0cy5vblVwbG9hZFByb2dyZXNzPy4oe1xuICAgICAgICAgICAgICAgIGZpbGU6IGZpbGUubmFtZSxcbiAgICAgICAgICAgICAgICBwcm9ncmVzczogcC5sb2FkZWQgLyBwLnRvdGFsICogMTAwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgeGhyLm9ubG9hZCA9ICgpPT5yZXNvbHZlKHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IHhoci5zdGF0dXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB4aHIub25lcnJvciA9IChlKT0+cmVqZWN0KGUpO1xuICAgICAgICB4aHIuc2VuZChmb3JtRGF0YSk7XG4gICAgfSkuY2F0Y2goYXN5bmMgKGVycm9yKT0+e1xuICAgICAgICBhd2FpdCBvcHRzLnJlcG9ydEV2ZW50VG9VVChcImZhaWx1cmVcIiwge1xuICAgICAgICAgICAgZmlsZUtleTogcHJlc2lnbmVkLmtleSxcbiAgICAgICAgICAgIHVwbG9hZElkOiBudWxsLFxuICAgICAgICAgICAgZmlsZU5hbWU6IGZpbGUubmFtZSxcbiAgICAgICAgICAgIHMzRXJyb3I6IGVycm9yLnRvU3RyaW5nKClcbiAgICAgICAgfSk7XG4gICAgICAgIHRocm93IFwidW5yZWFjaGFibGVcIjsgLy8gZmFpbHVyZSBldmVudCB3aWxsIHRocm93IGZvciB1c1xuICAgIH0pO1xuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPiAyOTkgfHwgcmVzcG9uc2Uuc3RhdHVzIDwgMjAwKSB7XG4gICAgICAgIGF3YWl0IG9wdHMucmVwb3J0RXZlbnRUb1VUKFwiZmFpbHVyZVwiLCB7XG4gICAgICAgICAgICBmaWxlS2V5OiBwcmVzaWduZWQua2V5LFxuICAgICAgICAgICAgdXBsb2FkSWQ6IG51bGwsXG4gICAgICAgICAgICBmaWxlTmFtZTogZmlsZS5uYW1lXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgZ2VuVXBsb2FkZXIsIHZlcnNpb24gfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/uploadthing/client/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/uploadthing/internal/types.js":
/*!****************************************************!*\
  !*** ./node_modules/uploadthing/internal/types.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UTFiles: () => (/* binding */ UTFiles),\n/* harmony export */   VALID_ACTION_TYPES: () => (/* binding */ VALID_ACTION_TYPES)\n/* harmony export */ });\n/**\n * Marker used to append a `customId` to the incoming file data in `.middleware()`\n * @example\n * ```ts\n * .middleware((opts) => {\n *   return {\n *     [UTFiles]: opts.files.map((file) => ({\n *       ...file,\n *       customId: generateId(),\n *     }))\n *   };\n * })\n * ```\n */ const UTFiles = Symbol(\"uploadthing-custom-id-symbol\");\n/**\n * Valid options for the `?actionType` query param\n */ const VALID_ACTION_TYPES = [\n    \"upload\",\n    \"failure\",\n    \"multipart-complete\"\n];\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXBsb2FkdGhpbmcvaW50ZXJuYWwvdHlwZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV1QyIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy91cGxvYWR0aGluZy9pbnRlcm5hbC90eXBlcy5qcz83MWVkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTWFya2VyIHVzZWQgdG8gYXBwZW5kIGEgYGN1c3RvbUlkYCB0byB0aGUgaW5jb21pbmcgZmlsZSBkYXRhIGluIGAubWlkZGxld2FyZSgpYFxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiAubWlkZGxld2FyZSgob3B0cykgPT4ge1xuICogICByZXR1cm4ge1xuICogICAgIFtVVEZpbGVzXTogb3B0cy5maWxlcy5tYXAoKGZpbGUpID0+ICh7XG4gKiAgICAgICAuLi5maWxlLFxuICogICAgICAgY3VzdG9tSWQ6IGdlbmVyYXRlSWQoKSxcbiAqICAgICB9KSlcbiAqICAgfTtcbiAqIH0pXG4gKiBgYGBcbiAqLyBjb25zdCBVVEZpbGVzID0gU3ltYm9sKFwidXBsb2FkdGhpbmctY3VzdG9tLWlkLXN5bWJvbFwiKTtcbi8qKlxuICogVmFsaWQgb3B0aW9ucyBmb3IgdGhlIGA/YWN0aW9uVHlwZWAgcXVlcnkgcGFyYW1cbiAqLyBjb25zdCBWQUxJRF9BQ1RJT05fVFlQRVMgPSBbXG4gICAgXCJ1cGxvYWRcIixcbiAgICBcImZhaWx1cmVcIixcbiAgICBcIm11bHRpcGFydC1jb21wbGV0ZVwiXG5dO1xuXG5leHBvcnQgeyBVVEZpbGVzLCBWQUxJRF9BQ1RJT05fVFlQRVMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/uploadthing/internal/types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/uploadthing/next/index.js":
/*!************************************************!*\
  !*** ./node_modules/uploadthing/next/index.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UTFiles: () => (/* reexport safe */ uploadthing_internal_types__WEBPACK_IMPORTED_MODULE_1__.UTFiles),\n/* harmony export */   createNextRouteHandler: () => (/* binding */ createNextRouteHandler),\n/* harmony export */   createRouteHandler: () => (/* binding */ createRouteHandler),\n/* harmony export */   createUploadthing: () => (/* binding */ createUploadthing)\n/* harmony export */ });\n/* harmony import */ var uploadthing_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uploadthing/server */ \"(ssr)/./node_modules/uploadthing/server/index.js\");\n/* harmony import */ var uploadthing_internal_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uploadthing/internal/types */ \"(ssr)/./node_modules/uploadthing/internal/types.js\");\n\n\n\nfunction defaultErrorFormatter(error) {\n    return {\n        message: error.message\n    };\n}\n\nfunction internalCreateBuilder(initDef = {}) {\n    const _def = {\n        // Default router config\n        routerConfig: {\n            image: {\n                maxFileSize: \"4MB\"\n            }\n        },\n        inputParser: {\n            parse: ()=>undefined,\n            _input: undefined,\n            _output: undefined\n        },\n        middleware: ()=>({}),\n        onUploadError: ()=>({}),\n        errorFormatter: initDef.errorFormatter ?? defaultErrorFormatter,\n        // Overload with properties passed in\n        ...initDef\n    };\n    return {\n        input (userParser) {\n            return internalCreateBuilder({\n                ..._def,\n                inputParser: userParser\n            });\n        },\n        middleware (userMiddleware) {\n            return internalCreateBuilder({\n                ..._def,\n                middleware: userMiddleware\n            });\n        },\n        onUploadComplete (userUploadComplete) {\n            return {\n                _def,\n                resolver: userUploadComplete\n            };\n        },\n        onUploadError (userOnUploadError) {\n            return internalCreateBuilder({\n                ..._def,\n                onUploadError: userOnUploadError\n            });\n        }\n    };\n}\nfunction createBuilder(opts) {\n    return (input)=>{\n        return internalCreateBuilder({\n            routerConfig: input,\n            ...opts\n        });\n    };\n}\n\nconst createUploadthing = (opts)=>createBuilder(opts);\nconst createRouteHandler = (opts)=>{\n    const handlers = (0,uploadthing_server__WEBPACK_IMPORTED_MODULE_0__.INTERNAL_DO_NOT_USE_createRouteHandlerCore)(opts, \"nextjs-app\");\n    return {\n        POST: (req)=>handlers.POST(req),\n        GET: (req)=>handlers.GET(req)\n    };\n};\n/**\n * @deprecated Use {@link createRouteHandler} instead\n */ const createNextRouteHandler = createRouteHandler;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXBsb2FkdGhpbmcvbmV4dC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBZ0Y7QUFDM0I7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCwyQkFBMkI7QUFDM0IsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsOEZBQTBDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7O0FBRXlFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL3VwbG9hZHRoaW5nL25leHQvaW5kZXguanM/NDc3NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJTlRFUk5BTF9ET19OT1RfVVNFX2NyZWF0ZVJvdXRlSGFuZGxlckNvcmUgfSBmcm9tICd1cGxvYWR0aGluZy9zZXJ2ZXInO1xuZXhwb3J0IHsgVVRGaWxlcyB9IGZyb20gJ3VwbG9hZHRoaW5nL2ludGVybmFsL3R5cGVzJztcblxuZnVuY3Rpb24gZGVmYXVsdEVycm9yRm9ybWF0dGVyKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGludGVybmFsQ3JlYXRlQnVpbGRlcihpbml0RGVmID0ge30pIHtcbiAgICBjb25zdCBfZGVmID0ge1xuICAgICAgICAvLyBEZWZhdWx0IHJvdXRlciBjb25maWdcbiAgICAgICAgcm91dGVyQ29uZmlnOiB7XG4gICAgICAgICAgICBpbWFnZToge1xuICAgICAgICAgICAgICAgIG1heEZpbGVTaXplOiBcIjRNQlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGlucHV0UGFyc2VyOiB7XG4gICAgICAgICAgICBwYXJzZTogKCk9PnVuZGVmaW5lZCxcbiAgICAgICAgICAgIF9pbnB1dDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgX291dHB1dDogdW5kZWZpbmVkXG4gICAgICAgIH0sXG4gICAgICAgIG1pZGRsZXdhcmU6ICgpPT4oe30pLFxuICAgICAgICBvblVwbG9hZEVycm9yOiAoKT0+KHt9KSxcbiAgICAgICAgZXJyb3JGb3JtYXR0ZXI6IGluaXREZWYuZXJyb3JGb3JtYXR0ZXIgPz8gZGVmYXVsdEVycm9yRm9ybWF0dGVyLFxuICAgICAgICAvLyBPdmVybG9hZCB3aXRoIHByb3BlcnRpZXMgcGFzc2VkIGluXG4gICAgICAgIC4uLmluaXREZWZcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGlucHV0ICh1c2VyUGFyc2VyKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxDcmVhdGVCdWlsZGVyKHtcbiAgICAgICAgICAgICAgICAuLi5fZGVmLFxuICAgICAgICAgICAgICAgIGlucHV0UGFyc2VyOiB1c2VyUGFyc2VyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgbWlkZGxld2FyZSAodXNlck1pZGRsZXdhcmUpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbENyZWF0ZUJ1aWxkZXIoe1xuICAgICAgICAgICAgICAgIC4uLl9kZWYsXG4gICAgICAgICAgICAgICAgbWlkZGxld2FyZTogdXNlck1pZGRsZXdhcmVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvblVwbG9hZENvbXBsZXRlICh1c2VyVXBsb2FkQ29tcGxldGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgX2RlZixcbiAgICAgICAgICAgICAgICByZXNvbHZlcjogdXNlclVwbG9hZENvbXBsZXRlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBvblVwbG9hZEVycm9yICh1c2VyT25VcGxvYWRFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGludGVybmFsQ3JlYXRlQnVpbGRlcih7XG4gICAgICAgICAgICAgICAgLi4uX2RlZixcbiAgICAgICAgICAgICAgICBvblVwbG9hZEVycm9yOiB1c2VyT25VcGxvYWRFcnJvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQnVpbGRlcihvcHRzKSB7XG4gICAgcmV0dXJuIChpbnB1dCk9PntcbiAgICAgICAgcmV0dXJuIGludGVybmFsQ3JlYXRlQnVpbGRlcih7XG4gICAgICAgICAgICByb3V0ZXJDb25maWc6IGlucHV0LFxuICAgICAgICAgICAgLi4ub3B0c1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuXG5jb25zdCBjcmVhdGVVcGxvYWR0aGluZyA9IChvcHRzKT0+Y3JlYXRlQnVpbGRlcihvcHRzKTtcbmNvbnN0IGNyZWF0ZVJvdXRlSGFuZGxlciA9IChvcHRzKT0+e1xuICAgIGNvbnN0IGhhbmRsZXJzID0gSU5URVJOQUxfRE9fTk9UX1VTRV9jcmVhdGVSb3V0ZUhhbmRsZXJDb3JlKG9wdHMsIFwibmV4dGpzLWFwcFwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBQT1NUOiAocmVxKT0+aGFuZGxlcnMuUE9TVChyZXEpLFxuICAgICAgICBHRVQ6IChyZXEpPT5oYW5kbGVycy5HRVQocmVxKVxuICAgIH07XG59O1xuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIGNyZWF0ZVJvdXRlSGFuZGxlcn0gaW5zdGVhZFxuICovIGNvbnN0IGNyZWF0ZU5leHRSb3V0ZUhhbmRsZXIgPSBjcmVhdGVSb3V0ZUhhbmRsZXI7XG5cbmV4cG9ydCB7IGNyZWF0ZU5leHRSb3V0ZUhhbmRsZXIsIGNyZWF0ZVJvdXRlSGFuZGxlciwgY3JlYXRlVXBsb2FkdGhpbmcgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/uploadthing/next/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/uploadthing/server/index.js":
/*!**************************************************!*\
  !*** ./node_modules/uploadthing/server/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   INTERNAL_DO_NOT_USE_createRouteHandlerCore: () => (/* binding */ INTERNAL_DO_NOT_USE_createRouteHandlerCore),\n/* harmony export */   UTApi: () => (/* binding */ UTApi),\n/* harmony export */   UTFile: () => (/* binding */ UTFile),\n/* harmony export */   UTFiles: () => (/* reexport safe */ uploadthing_internal_types__WEBPACK_IMPORTED_MODULE_2__.UTFiles),\n/* harmony export */   UploadThingError: () => (/* reexport safe */ _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError),\n/* harmony export */   createRouteHandler: () => (/* binding */ createRouteHandler),\n/* harmony export */   createServerHandler: () => (/* binding */ createServerHandler),\n/* harmony export */   createUploadthing: () => (/* binding */ createUploadthing),\n/* harmony export */   extractRouterConfig: () => (/* binding */ extractRouterConfig)\n/* harmony export */ });\n/* harmony import */ var _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @uploadthing/shared */ \"(ssr)/./node_modules/@uploadthing/shared/dist/index.js\");\n/* harmony import */ var std_env__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! std-env */ \"(ssr)/./node_modules/std-env/dist/index.mjs\");\n/* harmony import */ var consola_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! consola/core */ \"(ssr)/./node_modules/consola/dist/core.mjs\");\n/* harmony import */ var uploadthing_internal_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uploadthing/internal/types */ \"(ssr)/./node_modules/uploadthing/internal/types.js\");\n/* harmony import */ var _uploadthing_mime_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @uploadthing/mime-types */ \"(ssr)/./node_modules/@uploadthing/mime-types/dist/index.js\");\n\n\n\n\n\n\n\n\nvar version = \"6.7.0\";\n\nfunction defaultErrorFormatter(error) {\n    return {\n        message: error.message\n    };\n}\nfunction formatError(error, router) {\n    const errorFormatter = router[Object.keys(router)[0]]?._def.errorFormatter ?? defaultErrorFormatter;\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return errorFormatter(error);\n}\n\nconst colorize = (str, level)=>{\n    // TODO: Maybe check is shell supports colors\n    switch(level){\n        case \"error\":\n        case \"fatal\":\n            return `\\x1b[41m\\x1b[30m${str}\\x1b[0m`;\n        case \"warn\":\n            return `\\x1b[43m\\x1b[30m${str}\\x1b[0m`;\n        case \"info\":\n        case \"log\":\n            return `\\x1b[44m\\x1b[30m${str}\\x1b[0m`;\n        case \"debug\":\n            return `\\x1b[47m\\x1b[30m${str}\\x1b[0m`;\n        case \"trace\":\n            return `\\x1b[47m\\x1b[30m${str}\\x1b[0m`;\n        case \"success\":\n            return `\\x1b[42m\\x1b[30m${str}\\x1b[0m`;\n        default:\n            return str;\n    }\n};\nconst icons = {\n    fatal: \"⨯\",\n    error: \"⨯\",\n    warn: \"⚠️\",\n    info: \"ℹ\",\n    log: \"ℹ\",\n    debug: \"⚙\",\n    trace: \"→\",\n    success: \"✓\"\n};\nfunction formatStack(stack) {\n    const cwd = \"cwd\" in std_env__WEBPACK_IMPORTED_MODULE_4__.process && typeof std_env__WEBPACK_IMPORTED_MODULE_4__.process.cwd === \"function\" ? std_env__WEBPACK_IMPORTED_MODULE_4__.process.cwd() : \"__UnknownCWD__\";\n    return \"  \" + stack.split(\"\\n\").splice(1).map((l)=>l.trim().replace(\"file://\", \"\").replace(cwd + \"/\", \"\")).join(\"\\n  \");\n}\nfunction formatArgs(args) {\n    const fmtArgs = args.map((arg)=>{\n        if ((0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(arg) && typeof arg.stack === \"string\") {\n            return arg.message + \"\\n\" + formatStack(arg.stack);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return arg;\n    });\n    return fmtArgs.map((arg)=>{\n        if (typeof arg === \"string\") {\n            return arg;\n        }\n        return JSON.stringify(arg, null, 4);\n    });\n}\nconst logger = (0,consola_core__WEBPACK_IMPORTED_MODULE_1__.createConsola)({\n    reporters: [\n        {\n            log: (logObj)=>{\n                const { type, tag, date, args } = logObj;\n                const icon = icons[type];\n                const logPrefix = colorize(` ${icon} ${tag} ${date.toLocaleTimeString()} `, type);\n                const lines = formatArgs(args).join(\" \") // concat all arguments to one space-separated string (like console does)\n                .split(\"\\n\") // split all the newlines (e.g. from logged JSON.stringified objects)\n                .map((l)=>logPrefix + \" \" + l) // prepend the log prefix to each line\n                .join(\"\\n\"); // join all the lines back together\n                // eslint-disable-next-line no-console\n                console.log(lines);\n            }\n        }\n    ],\n    defaults: {\n        tag: \"UPLOADTHING\"\n    }\n});\nconst initLogger = (level)=>{\n    // logger.wrapConsole();\n    logger.level = consola_core__WEBPACK_IMPORTED_MODULE_1__.LogLevels[level ?? \"info\"];\n};\n\nconst isValidResponse = (response)=>{\n    if (!response.ok) return false;\n    if (response.status >= 400) return false;\n    if (!response.headers.has(\"x-uploadthing-version\")) return false;\n    return true;\n};\nconst conditionalDevServer = async (opts)=>{\n    const fileData = await (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.pollForFileData)({\n        url: (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.generateUploadThingURL)(`/api/pollUpload/${opts.fileKey}`),\n        apiKey: opts.apiKey,\n        sdkVersion: version,\n        fetch: opts.fetch\n    }, async (json)=>{\n        const file = json.fileData;\n        let callbackUrl = file.callbackUrl + `?slug=${file.callbackSlug}`;\n        if (!callbackUrl.startsWith(\"http\")) callbackUrl = \"http://\" + callbackUrl;\n        logger.info(\"SIMULATING FILE UPLOAD WEBHOOK CALLBACK\", callbackUrl);\n        const payload = JSON.stringify({\n            status: \"uploaded\",\n            metadata: JSON.parse(file.metadata ?? \"{}\"),\n            file: {\n                url: `https://utfs.io/f/${encodeURIComponent(opts.fileKey)}`,\n                key: opts.fileKey,\n                name: file.fileName,\n                size: file.fileSize,\n                type: file.fileType,\n                customId: file.customId\n            }\n        });\n        const signature = await (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.signPayload)(payload, opts.apiKey);\n        try {\n            const response = await opts.fetch(callbackUrl, {\n                method: \"POST\",\n                body: payload,\n                headers: {\n                    \"uploadthing-hook\": \"callback\",\n                    \"x-uploadthing-signature\": signature\n                }\n            });\n            if (isValidResponse(response)) {\n                logger.success(\"Successfully simulated callback for file\", opts.fileKey);\n            } else {\n                throw new Error(\"Invalid response\");\n            }\n        } catch (e) {\n            logger.error(`Failed to simulate callback for file '${opts.fileKey}'. Is your webhook configured correctly?`);\n            logger.error(`  - Make sure the URL '${callbackUrl}' is accessible without any authentication. You can verify this by running 'curl -X POST ${callbackUrl}' in your terminal`);\n            logger.error(`  - Still facing issues? Read https://docs.uploadthing.com/faq for common issues`);\n        }\n        return file;\n    });\n    if (fileData !== undefined) return fileData;\n    logger.error(`Failed to simulate callback for file ${opts.fileKey}`);\n    throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n        code: \"UPLOAD_FAILED\",\n        message: \"File took too long to upload\"\n    });\n};\n\nfunction getParseFn(parser) {\n    if (typeof parser.parse === \"function\") {\n        return parser.parse;\n    }\n    throw new Error(\"Invalid parser\");\n}\n\n/**\n * Creates a wrapped fetch that will always forward a few headers to the server.\n */ const createUTFetch = (apiKey, fetch, fePackage, beAdapter)=>{\n    return async (endpoint, payload)=>{\n        const response = await fetch((0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.generateUploadThingURL)(endpoint), {\n            method: \"POST\",\n            body: JSON.stringify(payload),\n            headers: {\n                \"Content-Type\": \"application/json\",\n                \"x-uploadthing-api-key\": apiKey,\n                \"x-uploadthing-version\": version,\n                \"x-uploadthing-fe-package\": fePackage,\n                \"x-uploadthing-be-adapter\": beAdapter\n            }\n        });\n        return response;\n    };\n};\nconst fileCountLimitHit = (files, routeConfig)=>{\n    const counts = {};\n    files.forEach((file)=>{\n        const type = (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.getTypeFromFileName)(file.name, (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.objectKeys)(routeConfig));\n        if (!counts[type]) {\n            counts[type] = 1;\n        } else {\n            counts[type] += 1;\n        }\n    });\n    for(const _key in counts){\n        const key = _key;\n        const count = counts[key];\n        const limit = routeConfig[key]?.maxFileCount;\n        if (!limit) {\n            logger.error(routeConfig, key);\n            throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"BAD_REQUEST\",\n                message: \"Invalid config during file count\",\n                cause: `Expected route config to have a maxFileCount for key ${key} but none was found.`\n            });\n        }\n        if (count > limit) {\n            return {\n                limitHit: true,\n                type: key,\n                limit,\n                count\n            };\n        }\n    }\n    return {\n        limitHit: false\n    };\n};\nconst buildRequestHandler = (opts, adapter)=>{\n    return async (input)=>{\n        const isDev = opts.config?.isDev ?? std_env__WEBPACK_IMPORTED_MODULE_4__.isDevelopment;\n        const fetch = opts.config?.fetch ?? globalThis.fetch;\n        if (isDev) {\n            logger.info(\"UploadThing dev server is now running!\");\n        }\n        const { router, config } = opts;\n        const preferredOrEnvSecret = config?.uploadthingSecret ?? std_env__WEBPACK_IMPORTED_MODULE_4__.process.env.UPLOADTHING_SECRET;\n        const req = input.req;\n        const url = new URL(req.url);\n        // Get inputs from query and params\n        const params = url.searchParams;\n        const uploadthingHook = req.headers.get(\"uploadthing-hook\") ?? undefined;\n        const slug = params.get(\"slug\") ?? undefined;\n        const actionType = params.get(\"actionType\") ?? undefined;\n        const utFrontendPackage = req.headers.get(\"x-uploadthing-package\") ?? \"unknown\";\n        const clientVersion = req.headers.get(\"x-uploadthing-version\");\n        if (clientVersion != null && clientVersion !== version) {\n            logger.error(\"Client version mismatch\");\n            return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"BAD_REQUEST\",\n                message: \"Client version mismatch\",\n                cause: `Server version: ${version}, Client version: ${clientVersion}`\n            });\n        }\n        // Validate inputs\n        if (!slug) {\n            logger.error(\"No slug provided in params:\", params);\n            return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"BAD_REQUEST\",\n                message: \"No slug provided in params\"\n            });\n        }\n        if (slug && typeof slug !== \"string\") {\n            const msg = `Expected slug to be of type 'string', got '${typeof slug}'`;\n            logger.error(msg);\n            return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"BAD_REQUEST\",\n                message: \"`slug` must be a string\",\n                cause: msg\n            });\n        }\n        if (actionType && typeof actionType !== \"string\") {\n            const msg = `Expected actionType to be of type 'string', got '${typeof actionType}'`;\n            logger.error(msg);\n            return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"BAD_REQUEST\",\n                message: \"`actionType` must be a string\",\n                cause: msg\n            });\n        }\n        if (uploadthingHook && typeof uploadthingHook !== \"string\") {\n            const msg = `Expected uploadthingHook to be of type 'string', got '${typeof uploadthingHook}'`;\n            return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"BAD_REQUEST\",\n                message: \"`uploadthingHook` must be a string\",\n                cause: msg\n            });\n        }\n        if (!preferredOrEnvSecret) {\n            const msg = `No secret provided, please set UPLOADTHING_SECRET in your env file or in the config`;\n            logger.error(msg);\n            return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"MISSING_ENV\",\n                message: `No secret provided`,\n                cause: msg\n            });\n        }\n        if (!preferredOrEnvSecret.startsWith(\"sk_\")) {\n            const msg = `Invalid secret provided, UPLOADTHING_SECRET must start with 'sk_'`;\n            logger.error(msg);\n            return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"MISSING_ENV\",\n                message: \"Invalid API key. API keys must start with 'sk_'.\",\n                cause: msg\n            });\n        }\n        if (utFrontendPackage && typeof utFrontendPackage !== \"string\") {\n            const msg = `Expected x-uploadthing-package to be of type 'string', got '${typeof utFrontendPackage}'`;\n            logger.error(msg);\n            return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"BAD_REQUEST\",\n                message: \"`x-uploadthing-package` must be a string. eg. '@uploadthing/react'\",\n                cause: msg\n            });\n        }\n        const uploadable = router[slug];\n        if (!uploadable) {\n            const msg = `No file route found for slug ${slug}`;\n            logger.error(msg);\n            return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"NOT_FOUND\",\n                message: msg\n            });\n        }\n        const utFetch = createUTFetch(preferredOrEnvSecret, fetch, utFrontendPackage, adapter);\n        logger.debug(\"All request input is valid\", {\n            slug,\n            actionType,\n            uploadthingHook\n        });\n        if (uploadthingHook === \"callback\") {\n            // This is when we receive the webhook from uploadthing\n            const maybeReqBody = await (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.safeParseJSON)(req);\n            logger.debug(\"Handling callback request with input:\", maybeReqBody);\n            if (maybeReqBody instanceof Error) {\n                logger.error(\"Invalid request body\", maybeReqBody);\n                return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                    code: \"BAD_REQUEST\",\n                    message: \"Invalid request body\",\n                    cause: maybeReqBody\n                });\n            }\n            const verified = await (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.verifySignature)(JSON.stringify(maybeReqBody), req.headers.get(\"x-uploadthing-signature\"), preferredOrEnvSecret);\n            logger.debug(\"Signature verified:\", verified);\n            if (!verified) {\n                logger.error(\"Invalid signature\");\n                return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                    code: \"BAD_REQUEST\",\n                    message: \"Invalid signature\"\n                });\n            }\n            const resolverArgs = {\n                file: maybeReqBody.file,\n                metadata: maybeReqBody.metadata\n            };\n            logger.debug(\"Running 'onUploadComplete' callback with input:\", resolverArgs);\n            const res = await uploadable.resolver(resolverArgs);\n            const payload = {\n                fileKey: maybeReqBody.file.key,\n                callbackData: res ?? null\n            };\n            logger.debug(\"'onUploadComplete' callback finished. Sending response to UploadThing:\", payload);\n            const callbackResponse = await utFetch(\"/api/serverCallback\", payload);\n            logger.debug(\"UploadThing responded with status:\", callbackResponse.status);\n            return {\n                status: 200,\n                body: null\n            };\n        }\n        if (!actionType || !uploadthing_internal_types__WEBPACK_IMPORTED_MODULE_2__.VALID_ACTION_TYPES.includes(actionType)) {\n            // This would either be someone spamming or the AWS webhook\n            const msg = `Expected ${uploadthing_internal_types__WEBPACK_IMPORTED_MODULE_2__.VALID_ACTION_TYPES.map((x)=>`\"${x}\"`).join(\", \").replace(/,(?!.*,)/, \" or\")} but got \"${actionType}\"`;\n            logger.error(\"Invalid action type.\", msg);\n            return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"BAD_REQUEST\",\n                cause: `Invalid action type ${actionType}`,\n                message: msg\n            });\n        }\n        switch(actionType){\n            case \"upload\":\n                {\n                    const maybeInput = await (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.safeParseJSON)(req);\n                    if (maybeInput instanceof Error) {\n                        logger.error(\"Invalid request body\", maybeInput);\n                        return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                            code: \"BAD_REQUEST\",\n                            message: \"Invalid request body\",\n                            cause: maybeInput\n                        });\n                    }\n                    logger.debug(\"Handling upload request with input:\", maybeInput);\n                    const { files, input: userInput } = maybeInput;\n                    // Validate without Zod (for now)\n                    if (!Array.isArray(files) || !files.every((f)=>(0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(f) && typeof f.name === \"string\" && typeof f.size === \"number\" && typeof f.type === \"string\")) {\n                        const msg = `Expected files to be of type '{name:string, size:number, type:string}[]', got '${JSON.stringify(files)}'`;\n                        logger.error(msg);\n                        return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                            code: \"BAD_REQUEST\",\n                            message: \"Files must be an array of objects with name and size\",\n                            cause: msg\n                        });\n                    }\n                    // validate the input\n                    let parsedInput = {};\n                    try {\n                        logger.debug(\"Parsing input\");\n                        const inputParser = uploadable._def.inputParser;\n                        parsedInput = await getParseFn(inputParser)(userInput);\n                        logger.debug(\"Input parsed successfully\", parsedInput);\n                    } catch (error) {\n                        logger.error(\"An error occurred trying to parse input:\", error);\n                        return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                            code: \"BAD_REQUEST\",\n                            message: \"Invalid input.\",\n                            cause: error\n                        });\n                    }\n                    let metadata = {};\n                    try {\n                        logger.debug(\"Running middleware\");\n                        metadata = await uploadable._def.middleware({\n                            ...input.middlewareArgs,\n                            input: parsedInput,\n                            files\n                        });\n                        logger.debug(\"Middleware finished successfully with:\", metadata);\n                    } catch (error) {\n                        logger.error(\"An error occurred in your middleware function:\", error);\n                        if (error instanceof _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError) return error;\n                        return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                            code: \"INTERNAL_SERVER_ERROR\",\n                            message: \"Failed to run middleware.\",\n                            cause: error\n                        });\n                    }\n                    if (metadata[uploadthing_internal_types__WEBPACK_IMPORTED_MODULE_2__.UTFiles] && metadata[uploadthing_internal_types__WEBPACK_IMPORTED_MODULE_2__.UTFiles].length !== files.length) {\n                        const msg = `Expected files override to have the same length as original files, got ${metadata[uploadthing_internal_types__WEBPACK_IMPORTED_MODULE_2__.UTFiles].length} but expected ${files.length}`;\n                        logger.error(msg);\n                        return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                            code: \"BAD_REQUEST\",\n                            message: \"Files override must have the same length as files\",\n                            cause: msg\n                        });\n                    }\n                    // Attach customIds from middleware to the files\n                    const filesWithCustomIds = files.map((file, idx)=>{\n                        const theirs = metadata[uploadthing_internal_types__WEBPACK_IMPORTED_MODULE_2__.UTFiles]?.[idx];\n                        if (theirs && theirs.size !== file.size) {\n                            logger.warn(\"File size mismatch. Reverting to original size\");\n                        }\n                        return {\n                            name: theirs?.name ?? file.name,\n                            size: file.size,\n                            customId: theirs?.customId\n                        };\n                    });\n                    // FILL THE ROUTE CONFIG so the server only has one happy path\n                    let parsedConfig;\n                    try {\n                        logger.debug(\"Parsing route config\", uploadable._def.routerConfig);\n                        parsedConfig = (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.fillInputRouteConfig)(uploadable._def.routerConfig);\n                        logger.debug(\"Route config parsed successfully\", parsedConfig);\n                    } catch (error) {\n                        logger.error(\"Invalid route config\", error);\n                        return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                            code: \"BAD_REQUEST\",\n                            message: \"Invalid config.\",\n                            cause: error\n                        });\n                    }\n                    try {\n                        logger.debug(\"Checking file count limit\", files);\n                        const { limitHit, count, limit, type } = fileCountLimitHit(files, parsedConfig);\n                        if (limitHit) {\n                            const msg = `You uploaded ${count} files of type '${type}', but the limit for that type is ${limit}`;\n                            logger.error(msg);\n                            return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                                code: \"BAD_REQUEST\",\n                                message: \"File limit exceeded\",\n                                cause: msg\n                            });\n                        }\n                        logger.debug(\"File count limit check passed\");\n                    } catch (error) {\n                        logger.error(\"Invalid route config\", error);\n                        return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                            code: \"BAD_REQUEST\",\n                            message: \"Invalid config.\",\n                            cause: error\n                        });\n                    }\n                    const callbackUrl = resolveCallbackUrl({\n                        config,\n                        req,\n                        url,\n                        isDev\n                    });\n                    logger.debug(\"Retrieving presigned URLs from UploadThing. Callback URL is:\", callbackUrl.href);\n                    const uploadthingApiResponse = await utFetch(\"/api/prepareUpload\", {\n                        files: filesWithCustomIds,\n                        routeConfig: parsedConfig,\n                        metadata,\n                        callbackUrl: callbackUrl.origin + callbackUrl.pathname,\n                        callbackSlug: slug\n                    });\n                    // This is when we send the response back to the user's form so they can submit the files\n                    const parsedResponse = await (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.safeParseJSON)(uploadthingApiResponse);\n                    if (!uploadthingApiResponse.ok || parsedResponse instanceof Error) {\n                        logger.error(\"Unable to get presigned URLs\", parsedResponse);\n                        return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                            code: \"URL_GENERATION_FAILED\",\n                            message: \"Unable to get presigned urls\",\n                            cause: parsedResponse\n                        });\n                    }\n                    logger.debug(\"UploadThing responded with:\", parsedResponse);\n                    logger.debug(\"Sending presigned URLs to client\");\n                    // This is when we send the response back to the user's form so they can submit the files\n                    let promise = undefined;\n                    if (isDev) {\n                        promise = Promise.all(parsedResponse.map((file)=>conditionalDevServer({\n                                fileKey: file.key,\n                                apiKey: preferredOrEnvSecret,\n                                fetch\n                            }).catch((error)=>{\n                                logger.error(\"Err\", error);\n                            })));\n                    }\n                    return {\n                        cleanup: promise,\n                        body: parsedResponse,\n                        status: 200\n                    };\n                }\n            case \"multipart-complete\":\n                {\n                    const maybeReqBody = await (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.safeParseJSON)(req);\n                    if (maybeReqBody instanceof Error) {\n                        logger.error(\"Invalid request body\", maybeReqBody);\n                        return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                            code: \"BAD_REQUEST\",\n                            message: \"Invalid request body\",\n                            cause: maybeReqBody\n                        });\n                    }\n                    logger.debug(\"Handling multipart-complete request with input:\", maybeReqBody);\n                    logger.debug(\"Notifying UploadThing that multipart upload is complete\");\n                    const completeRes = await utFetch(\"/api/completeMultipart\", {\n                        fileKey: maybeReqBody.fileKey,\n                        uploadId: maybeReqBody.uploadId,\n                        etags: maybeReqBody.etags\n                    });\n                    if (!completeRes.ok) {\n                        logger.error(\"Failed to notify UploadThing that multipart upload is complete\");\n                        return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                            code: \"UPLOAD_FAILED\",\n                            message: \"Failed to complete multipart upload\",\n                            cause: completeRes\n                        });\n                    }\n                    logger.debug(\"UploadThing responded with:\", completeRes.status);\n                    return {\n                        status: 200,\n                        body: null\n                    };\n                }\n            case \"failure\":\n                {\n                    const maybeReqBody = await (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.safeParseJSON)(req);\n                    if (maybeReqBody instanceof Error) {\n                        logger.error(\"Invalid request body\", maybeReqBody);\n                        return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                            code: \"BAD_REQUEST\",\n                            message: \"Invalid request body\",\n                            cause: maybeReqBody\n                        });\n                    }\n                    const { fileKey, uploadId } = maybeReqBody;\n                    logger.debug(\"Handling failure request with input:\", maybeReqBody);\n                    logger.debug(\"Notifying UploadThing that upload failed\");\n                    // Tell uploadthing to mark the upload as failed\n                    const uploadthingApiResponse = await utFetch(\"/api/failureCallback\", {\n                        fileKey,\n                        uploadId\n                    });\n                    if (!uploadthingApiResponse.ok) {\n                        const parsedResponse = await (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.safeParseJSON)(uploadthingApiResponse);\n                        logger.error(\"Failed to mark upload as failed\", parsedResponse);\n                        return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                            code: \"INTERNAL_SERVER_ERROR\",\n                            message: \"Unable to mark upload as failed\",\n                            cause: parsedResponse\n                        });\n                    }\n                    logger.debug(\"UploadThing responded with:\", uploadthingApiResponse);\n                    logger.debug(\"Running 'onUploadError' callback\");\n                    try {\n                        // Run the onUploadError callback\n                        uploadable._def.onUploadError({\n                            error: new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                                code: \"UPLOAD_FAILED\",\n                                message: `Upload failed for ${fileKey}`\n                            }),\n                            fileKey\n                        });\n                    } catch (error) {\n                        logger.error(\"Failed to run onUploadError callback. You probably shouldn't be throwing errors in your callback.\", error);\n                        return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                            code: \"INTERNAL_SERVER_ERROR\",\n                            message: \"Failed to run onUploadError callback\",\n                            cause: error\n                        });\n                    }\n                    return {\n                        status: 200,\n                        body: null\n                    };\n                }\n            default:\n                {\n                    // This should never happen\n                    return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                        code: \"BAD_REQUEST\",\n                        message: `Invalid action type`\n                    });\n                }\n        }\n    };\n};\nfunction resolveCallbackUrl(opts) {\n    let callbackUrl = opts.url;\n    if (opts.config?.callbackUrl) {\n        callbackUrl = (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.resolveMaybeUrlArg)(opts.config.callbackUrl);\n    } else if (std_env__WEBPACK_IMPORTED_MODULE_4__.process.env.UPLOADTHING_URL) {\n        callbackUrl = (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.resolveMaybeUrlArg)(std_env__WEBPACK_IMPORTED_MODULE_4__.process.env.UPLOADTHING_URL);\n    }\n    if (opts.isDev || !callbackUrl.host.includes(\"localhost\")) {\n        return callbackUrl;\n    }\n    // Production builds have to have a public URL so UT can send webhook\n    // Parse the URL from the headers\n    const headers = opts.req.headers;\n    let parsedFromHeaders = headers.get(\"origin\") ?? headers.get(\"referer\") ?? headers.get(\"host\") ?? headers.get(\"x-forwarded-host\");\n    if (parsedFromHeaders && !parsedFromHeaders.includes(\"http\")) {\n        parsedFromHeaders = (headers.get(\"x-forwarded-proto\") ?? \"https\") + \"://\" + parsedFromHeaders;\n    }\n    if (!parsedFromHeaders || parsedFromHeaders.includes(\"localhost\")) {\n        // Didn't find a valid URL in the headers, log a warning and use the original url anyway\n        logger.warn(\"You are using a localhost callback url in production which is not supported.\", \"Read more and learn how to fix it here: https://docs.uploadthing.com/faq#my-callback-runs-in-development-but-not-in-production\");\n        return callbackUrl;\n    }\n    return (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.resolveMaybeUrlArg)(parsedFromHeaders);\n}\nconst buildPermissionsInfoHandler = (opts)=>{\n    return ()=>{\n        const r = opts.router;\n        const permissions = Object.keys(r).map((k)=>{\n            const route = r[k];\n            const config = (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.fillInputRouteConfig)(route._def.routerConfig);\n            return {\n                slug: k,\n                config\n            };\n        });\n        return permissions;\n    };\n};\n\nfunction incompatibleNodeGuard() {\n    if (typeof std_env__WEBPACK_IMPORTED_MODULE_4__.process === \"undefined\") return;\n    let major;\n    let minor;\n    const maybeNodeVersion = std_env__WEBPACK_IMPORTED_MODULE_4__.process.versions?.node?.split(\".\");\n    if (maybeNodeVersion) {\n        [major, minor] = maybeNodeVersion.map((v)=>parseInt(v, 10));\n    }\n    const maybeNodePath = std_env__WEBPACK_IMPORTED_MODULE_4__.process.env?.NODE;\n    if (!major && maybeNodePath) {\n        const nodeVersion = /v(\\d+)\\.(\\d+)\\.(\\d+)/.exec(maybeNodePath)?.[0];\n        if (nodeVersion) {\n            [major, minor] = nodeVersion.substring(1).split(\".\").map((v)=>parseInt(v, 10));\n        }\n    }\n    if (!major || !minor) return;\n    // Require ^18.13.0\n    if (major > 18) return;\n    if (major === 18 && minor >= 13) return;\n    logger.fatal(`YOU ARE USING A LEGACY (${major}.${minor}) NODE VERSION WHICH ISN'T OFFICIALLY SUPPORTED. PLEASE UPGRADE TO NODE ^18.13.`);\n    // Kill the process if it isn't going to work correctly anyway\n    // If we've gotten this far we know we have a Node.js runtime so exit is defined. Override std-env type.\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n    std_env__WEBPACK_IMPORTED_MODULE_4__.process.exit?.(1);\n}\n\nfunction internalCreateBuilder(initDef = {}) {\n    const _def = {\n        // Default router config\n        routerConfig: {\n            image: {\n                maxFileSize: \"4MB\"\n            }\n        },\n        inputParser: {\n            parse: ()=>undefined,\n            _input: undefined,\n            _output: undefined\n        },\n        middleware: ()=>({}),\n        onUploadError: ()=>({}),\n        errorFormatter: initDef.errorFormatter ?? defaultErrorFormatter,\n        // Overload with properties passed in\n        ...initDef\n    };\n    return {\n        input (userParser) {\n            return internalCreateBuilder({\n                ..._def,\n                inputParser: userParser\n            });\n        },\n        middleware (userMiddleware) {\n            return internalCreateBuilder({\n                ..._def,\n                middleware: userMiddleware\n            });\n        },\n        onUploadComplete (userUploadComplete) {\n            return {\n                _def,\n                resolver: userUploadComplete\n            };\n        },\n        onUploadError (userOnUploadError) {\n            return internalCreateBuilder({\n                ..._def,\n                onUploadError: userOnUploadError\n            });\n        }\n    };\n}\nfunction createBuilder(opts) {\n    return (input)=>{\n        return internalCreateBuilder({\n            routerConfig: input,\n            ...opts\n        });\n    };\n}\n\nconst maybeParseResponseXML = (maybeXml)=>{\n    const codeMatch = maybeXml.match(/<Code>(.*?)<\\/Code>/s);\n    const messageMatch = maybeXml.match(/<Message>(.*?)<\\/Message>/s);\n    const code = codeMatch?.[1];\n    const message = messageMatch?.[1];\n    if (!code || !message) return null;\n    return {\n        code: s3CodeToUploadThingCode[code] ?? DEFAULT_ERROR_CODE,\n        message\n    };\n};\n/**\n * Map S3 error codes to UploadThing error codes\n *\n * This is a subset of the S3 error codes, based on what seemed most likely to\n * occur in uploadthing. For a full list of S3 error codes, see:\n * https://docs.aws.amazon.com/AmazonS3/latest/API/ErrorResponses.html\n */ const DEFAULT_ERROR_CODE = \"UPLOAD_FAILED\";\nconst s3CodeToUploadThingCode = {\n    AccessDenied: \"FORBIDDEN\",\n    EntityTooSmall: \"TOO_SMALL\",\n    EntityTooLarge: \"TOO_LARGE\",\n    ExpiredToken: \"FORBIDDEN\",\n    IncorrectNumberOfFilesInPostRequest: \"TOO_MANY_FILES\",\n    InternalError: \"INTERNAL_SERVER_ERROR\",\n    KeyTooLongError: \"KEY_TOO_LONG\",\n    MaxMessageLengthExceeded: \"TOO_LARGE\"\n};\n\n/**\n * Used by server uploads where progress is not needed.\n * Uses normal fetch API.\n */ async function uploadPart(opts, retryCount = 0) {\n    const s3Res = await opts.fetch(opts.url, {\n        method: \"PUT\",\n        body: opts.chunk,\n        headers: {\n            \"Content-Type\": opts.contentType,\n            \"Content-Disposition\": (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.contentDisposition)(opts.contentDisposition, opts.fileName)\n        }\n    });\n    if (s3Res.ok) {\n        const etag = s3Res.headers.get(\"Etag\");\n        if (!etag) {\n            throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"UPLOAD_FAILED\",\n                message: \"Missing Etag header from uploaded part\"\n            });\n        }\n        return etag.replace(/\"/g, \"\");\n    }\n    if (retryCount < opts.maxRetries) {\n        // Retry after exponential backoff\n        const delay = 2 ** retryCount * 1000;\n        await new Promise((r)=>setTimeout(r, delay));\n        return uploadPart(opts, retryCount++);\n    }\n    // Max retries exceeded, tell UT server that upload failed\n    await opts.fetch((0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.generateUploadThingURL)(\"/api/failureCallback\"), {\n        method: \"POST\",\n        body: JSON.stringify({\n            fileKey: opts.key\n        }),\n        headers: opts.utRequestHeaders\n    });\n    const text = await s3Res.text();\n    const parsed = maybeParseResponseXML(text);\n    if (parsed?.message) {\n        throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n            code: \"UPLOAD_FAILED\",\n            message: parsed.message\n        });\n    }\n    throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n        code: \"UPLOAD_FAILED\",\n        message: \"Failed to upload file to storage provider\",\n        cause: s3Res\n    });\n}\n\nfunction guardServerOnly() {\n    if (typeof window !== \"undefined\") {\n        throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n            code: \"INTERNAL_SERVER_ERROR\",\n            message: \"The `utapi` can only be used on the server.\"\n        });\n    }\n}\nfunction getApiKeyOrThrow(apiKey) {\n    if (apiKey) return apiKey;\n    if (std_env__WEBPACK_IMPORTED_MODULE_4__.process.env.UPLOADTHING_SECRET) return std_env__WEBPACK_IMPORTED_MODULE_4__.process.env.UPLOADTHING_SECRET;\n    throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n        code: \"MISSING_ENV\",\n        message: \"Missing `UPLOADTHING_SECRET` env variable.\"\n    });\n}\nconst uploadFilesInternal = async (data, opts)=>{\n    // Request presigned URLs for each file\n    const fileData = data.files.map((file)=>({\n            name: file.name ?? \"unnamed-blob\",\n            type: file.type,\n            size: file.size,\n            ...\"customId\" in file ? {\n                customId: file.customId\n            } : {}\n        }));\n    logger.debug(\"Getting presigned URLs for files\", fileData);\n    const res = await opts.fetch((0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.generateUploadThingURL)(\"/api/uploadFiles\"), {\n        method: \"POST\",\n        headers: opts.utRequestHeaders,\n        cache: \"no-store\",\n        body: JSON.stringify({\n            files: fileData,\n            metadata: data.metadata,\n            contentDisposition: data.contentDisposition,\n            acl: data.acl\n        })\n    });\n    if (!res.ok) {\n        const error = await _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError.fromResponse(res);\n        logger.debug(\"Failed getting presigned URLs:\", error);\n        throw error;\n    }\n    const json = await res.json();\n    logger.debug(\"Got presigned URLs:\", json.data);\n    logger.debug(\"Starting uploads...\");\n    // Upload each file to S3 in chunks using multi-part uploads\n    const uploads = await Promise.allSettled(data.files.map(async (file, i)=>{\n        const presigned = json.data[i];\n        if (!presigned) {\n            logger.error(\"Failed to generate presigned URL for file:\", file, presigned);\n            throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"URL_GENERATION_FAILED\",\n                message: \"Failed to generate presigned URL\",\n                cause: JSON.stringify(presigned)\n            });\n        }\n        if (\"urls\" in presigned) {\n            await uploadMultipart(file, presigned, {\n                ...opts\n            });\n        } else {\n            await uploadPresignedPost(file, presigned, {\n                ...opts\n            });\n        }\n        // Poll for file to be available\n        logger.debug(\"Polling for file data...\");\n        await (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.pollForFileData)({\n            url: (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.generateUploadThingURL)(`/api/pollUpload/${presigned.key}`),\n            apiKey: opts.utRequestHeaders[\"x-uploadthing-api-key\"],\n            sdkVersion: version,\n            fetch: opts.fetch\n        });\n        logger.debug(\"Polling complete.\");\n        return {\n            key: presigned.key,\n            url: presigned.fileUrl,\n            name: file.name,\n            size: file.size,\n            type: file.type,\n            customId: \"customId\" in file ? file.customId ?? null : null\n        };\n    }));\n    logger.debug(\"All uploads complete, aggregating results...\");\n    return uploads.map((upload)=>{\n        if (upload.status === \"fulfilled\") {\n            const data = upload.value;\n            return {\n                data,\n                error: null\n            };\n        }\n        // We only throw UploadThingErrors, so this is safe\n        const reason = upload.reason;\n        const error = _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError.toObject(reason);\n        return {\n            data: null,\n            error\n        };\n    });\n};\nasync function uploadMultipart(file, presigned, opts) {\n    logger.debug(\"Uploading file\", file.name, \"with\", presigned.urls.length, \"chunks of size\", presigned.chunkSize, \"bytes each\");\n    const etags = await Promise.all(presigned.urls.map(async (url, index)=>{\n        const offset = presigned.chunkSize * index;\n        const end = Math.min(offset + presigned.chunkSize, file.size);\n        const chunk = file.slice(offset, end);\n        const etag = await uploadPart({\n            fetch: opts.fetch,\n            url,\n            chunk: chunk,\n            contentDisposition: presigned.contentDisposition,\n            contentType: file.type,\n            fileName: file.name,\n            maxRetries: 10,\n            key: presigned.key,\n            utRequestHeaders: opts.utRequestHeaders\n        });\n        logger.debug(\"Part\", index + 1, \"uploaded successfully:\", etag);\n        return {\n            tag: etag,\n            partNumber: index + 1\n        };\n    }));\n    logger.debug(\"File\", file.name, \"uploaded successfully. Notifying UploadThing to complete multipart upload.\");\n    // Complete multipart upload\n    const completionRes = await opts.fetch((0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.generateUploadThingURL)(\"/api/completeMultipart\"), {\n        method: \"POST\",\n        body: JSON.stringify({\n            fileKey: presigned.key,\n            uploadId: presigned.uploadId,\n            etags\n        }),\n        headers: opts.utRequestHeaders\n    });\n    logger.debug(\"UploadThing responsed with status:\", completionRes.status);\n}\nasync function uploadPresignedPost(file, presigned, opts) {\n    logger.debug(\"Uploading file\", file.name, \"using presigned POST URL\");\n    const formData = new FormData();\n    Object.entries(presigned.fields).forEach(([k, v])=>formData.append(k, v));\n    formData.append(\"file\", file); // File data **MUST GO LAST**\n    const res = await opts.fetch(presigned.url, {\n        method: \"POST\",\n        body: formData,\n        headers: new Headers({\n            Accept: \"application/xml\"\n        })\n    });\n    if (!res.ok) {\n        const text = await res.text();\n        logger.error(\"Failed to upload file:\", text);\n        throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n            code: \"UPLOAD_FAILED\",\n            message: \"Failed to upload file\",\n            cause: text\n        });\n    }\n    logger.debug(\"File\", file.name, \"uploaded successfully\");\n}\nfunction parseTimeToSeconds(time) {\n    const match = time.toString().split(/(\\d+)/).filter(Boolean);\n    const num = Number(match[0]);\n    const unit = (match[1] ?? \"s\").trim().slice(0, 1);\n    const multiplier = {\n        s: 1,\n        m: 60,\n        h: 3600,\n        d: 86400\n    }[unit];\n    return num * multiplier;\n}\n\n/**\n * Extension of the Blob class that simplifies setting the `name` and `customId` properties,\n * similar to the built-in File class from Node > 20.\n */ class UTFile extends Blob {\n    constructor(parts, name, options){\n        const optionsWithDefaults = {\n            ...options,\n            type: options?.type ?? ((0,_uploadthing_mime_types__WEBPACK_IMPORTED_MODULE_3__.lookup)(name) || undefined),\n            lastModified: options?.lastModified ?? Date.now()\n        };\n        super(parts, optionsWithDefaults);\n        this.name = name;\n        this.customId = optionsWithDefaults.customId;\n        this.lastModified = optionsWithDefaults.lastModified;\n    }\n}\nclass UTApi {\n    constructor(opts){\n        /**\n   * Request to delete files from UploadThing storage.\n   * @param {string | string[]} fileKeys\n   *\n   * @example\n   * await deleteFiles(\"2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\");\n   *\n   * @example\n   * await deleteFiles([\"2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\",\"1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg\"])\n   *\n   * @example\n   * await deleteFiles(\"myCustomIdentifier\", { keyType: \"customId\" })\n   */ this.deleteFiles = async (keys, opts)=>{\n            guardServerOnly();\n            const { keyType = this.defaultKeyType } = opts ?? {};\n            return this.requestUploadThing(\"/api/deleteFile\", keyType === \"fileKey\" ? {\n                fileKeys: (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.asArray)(keys)\n            } : {\n                customIds: (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.asArray)(keys)\n            }, \"An unknown error occurred while deleting files.\");\n        };\n        /**\n   * Request file URLs from UploadThing storage.\n   * @param {string | string[]} fileKeys\n   *\n   * @example\n   * const data = await getFileUrls(\"2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\");\n   * console.log(data); // [{key: \"2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\", url: \"https://uploadthing.com/f/2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\"}]\n   *\n   * @example\n   * const data = await getFileUrls([\"2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\",\"1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg\"])\n   * console.log(data) // [{key: \"2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\", url: \"https://uploadthing.com/f/2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\" },{key: \"1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg\", url: \"https://uploadthing.com/f/1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg\"}]\n   */ this.getFileUrls = async (keys, opts)=>{\n            guardServerOnly();\n            const { keyType = this.defaultKeyType } = opts ?? {};\n            const json = await this.requestUploadThing(\"/api/getFileUrl\", keyType === \"fileKey\" ? {\n                fileKeys: (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.asArray)(keys)\n            } : {\n                customIds: (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.asArray)(keys)\n            }, \"An unknown error occurred while retrieving file URLs.\");\n            return json.data;\n        };\n        /**\n   * Request file list from UploadThing storage.\n   * @param {object} opts\n   * @param {number} opts.limit The maximum number of files to return\n   * @param {number} opts.offset The number of files to skip\n   *\n   * @example\n   * const data = await listFiles({ limit: 1 });\n   * console.log(data); // { key: \"2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\", id: \"2e0fdb64-9957-4262-8e45-f372ba903ac8\" }\n   */ this.listFiles = async (opts)=>{\n            guardServerOnly();\n            const json = await this.requestUploadThing(\"/api/listFiles\", {\n                ...opts\n            }, \"An unknown error occurred while listing files.\");\n            return json.files;\n        };\n        this.renameFiles = async (updates)=>{\n            guardServerOnly();\n            return this.requestUploadThing(\"/api/renameFiles\", {\n                updates: (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.asArray)(updates)\n            }, \"An unknown error occurred while renaming files.\");\n        };\n        /** @deprecated Use {@link renameFiles} instead. */ this.renameFile = this.renameFiles;\n        this.getUsageInfo = async ()=>{\n            guardServerOnly();\n            return this.requestUploadThing(\"/api/getUsageInfo\", {}, \"An unknown error occurred while getting usage info.\");\n        };\n        /** Request a presigned url for a private file(s) */ this.getSignedURL = async (key, opts)=>{\n            guardServerOnly();\n            const expiresIn = opts?.expiresIn ? parseTimeToSeconds(opts.expiresIn) : undefined;\n            const { keyType = this.defaultKeyType } = opts ?? {};\n            if (opts?.expiresIn && isNaN(expiresIn)) {\n                throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                    code: \"BAD_REQUEST\",\n                    message: \"expiresIn must be a valid time string, for example '1d', '2 days', or a number of seconds.\"\n                });\n            }\n            if (expiresIn && expiresIn > 86400 * 7) {\n                throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                    code: \"BAD_REQUEST\",\n                    message: \"expiresIn must be less than 7 days (604800 seconds).\"\n                });\n            }\n            const json = await this.requestUploadThing(\"/api/requestFileAccess\", keyType === \"fileKey\" ? {\n                fileKey: key,\n                expiresIn\n            } : {\n                customId: key,\n                expiresIn\n            }, \"An unknown error occurred while retrieving presigned URLs.\");\n            return json.url;\n        };\n        this.fetch = opts?.fetch ?? globalThis.fetch;\n        this.apiKey = opts?.apiKey ?? std_env__WEBPACK_IMPORTED_MODULE_4__.process.env.UPLOADTHING_SECRET;\n        this.defaultHeaders = {\n            \"Content-Type\": \"application/json\",\n            \"x-uploadthing-api-key\": this.apiKey,\n            \"x-uploadthing-version\": version,\n            \"x-uploadthing-be-adapter\": \"server-sdk\"\n        };\n        this.defaultKeyType = opts?.defaultKeyType ?? \"fileKey\";\n        initLogger(opts?.logLevel);\n        // Assert some stuff\n        guardServerOnly();\n        getApiKeyOrThrow(this.apiKey);\n        if (!this.apiKey?.startsWith(\"sk_\")) {\n            throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"MISSING_ENV\",\n                message: \"Invalid API key. API keys must start with `sk_`.\"\n            });\n        }\n        incompatibleNodeGuard();\n    }\n    async requestUploadThing(pathname, body, fallbackErrorMessage) {\n        const url = (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.generateUploadThingURL)(pathname);\n        logger.debug(\"Requesting UploadThing:\", {\n            url,\n            body,\n            headers: this.defaultHeaders\n        });\n        const res = await this.fetch(url, {\n            method: \"POST\",\n            cache: \"no-store\",\n            headers: this.defaultHeaders,\n            body: JSON.stringify(body)\n        });\n        logger.debug(\"UploadThing responsed with status:\", res.status);\n        const json = await res.json();\n        if (!res.ok || \"error\" in json) {\n            logger.error(\"Error:\", json);\n            throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"INTERNAL_SERVER_ERROR\",\n                message: \"error\" in json && typeof json.error === \"string\" ? json.error : fallbackErrorMessage\n            });\n        }\n        logger.debug(\"UploadThing response:\", json);\n        return json;\n    }\n    async uploadFiles(files, opts) {\n        guardServerOnly();\n        const uploads = await uploadFilesInternal({\n            files: (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.asArray)(files),\n            metadata: opts?.metadata ?? {},\n            contentDisposition: opts?.contentDisposition ?? \"inline\",\n            acl: opts?.acl\n        }, {\n            fetch: this.fetch,\n            utRequestHeaders: this.defaultHeaders\n        });\n        const uploadFileResponse = Array.isArray(files) ? uploads : uploads[0];\n        logger.debug(\"Finished uploading:\", uploadFileResponse);\n        return uploadFileResponse;\n    }\n    async uploadFilesFromUrl(urls, opts) {\n        guardServerOnly();\n        const formData = new FormData();\n        formData.append(\"metadata\", JSON.stringify(opts?.metadata ?? {}));\n        const downloadErrors = {};\n        const files = await Promise.all((0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.asArray)(urls).map(async (_url, index)=>{\n            let url = (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(_url) ? _url.url : _url;\n            if (typeof url === \"string\") {\n                // since dataurls will result in name being too long, tell the user\n                // to use uploadFiles instead.\n                if (url.startsWith(\"data:\")) {\n                    downloadErrors[index] = _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError.toObject(new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                        code: \"BAD_REQUEST\",\n                        message: \"Please use uploadFiles() for data URLs. uploadFilesFromUrl() is intended for use with remote URLs only.\"\n                    }));\n                    return undefined;\n                }\n                url = new URL(url);\n            }\n            const { name = url.pathname.split(\"/\").pop() ?? \"unknown-filename\", customId = undefined } = (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(_url) ? _url : {};\n            // Download the file on the user's server to avoid egress charges\n            logger.debug(\"Downloading file:\", url);\n            const fileResponse = await this.fetch(url);\n            if (!fileResponse.ok) {\n                downloadErrors[index] = _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError.toObject(new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                    code: \"BAD_REQUEST\",\n                    message: \"Failed to download requested file.\",\n                    cause: fileResponse\n                }));\n                return undefined;\n            }\n            logger.debug(\"Finished downloading file. Reading blob...\");\n            const blob = await fileResponse.blob();\n            logger.debug(\"Finished reading blob.\");\n            return new UTFile([\n                blob\n            ], name, {\n                customId\n            });\n        })).then((files)=>files.filter((x)=>x !== undefined));\n        logger.debug(\"Uploading files:\", files);\n        const uploads = await uploadFilesInternal({\n            files,\n            metadata: opts?.metadata ?? {},\n            contentDisposition: opts?.contentDisposition ?? \"inline\",\n            acl: opts?.acl\n        }, {\n            fetch: this.fetch,\n            utRequestHeaders: this.defaultHeaders\n        });\n        /** Put it all back together, preserve the order of files */ const responses = (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.asArray)(urls).map((_, index)=>{\n            if (downloadErrors[index]) {\n                return {\n                    data: null,\n                    error: downloadErrors[index]\n                };\n            }\n            return uploads.shift();\n        });\n        /** Return single object or array based on input urls */ const uploadFileResponse = Array.isArray(urls) ? responses : responses[0];\n        logger.debug(\"Finished uploading:\", uploadFileResponse);\n        return uploadFileResponse;\n    }\n}\n\nconst createUploadthing = (opts)=>createBuilder(opts);\n/** @internal */ const INTERNAL_DO_NOT_USE_createRouteHandlerCore = (opts, adapter)=>{\n    initLogger(opts.config?.logLevel);\n    incompatibleNodeGuard();\n    const requestHandler = buildRequestHandler(opts, adapter);\n    const getBuildPerms = buildPermissionsInfoHandler(opts);\n    const POST = async (request)=>{\n        const req = request instanceof Request ? request : request.request;\n        const response = await requestHandler({\n            req,\n            middlewareArgs: {\n                req,\n                res: undefined,\n                event: undefined\n            }\n        });\n        if (response instanceof _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError) {\n            return new Response(JSON.stringify(formatError(response, opts.router)), {\n                status: (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.getStatusCodeFromError)(response),\n                headers: {\n                    \"x-uploadthing-version\": version\n                }\n            });\n        }\n        if (response.status !== 200) {\n            // We messed up - this should never happen\n            return new Response(\"An unknown error occurred\", {\n                status: 500,\n                headers: {\n                    \"x-uploadthing-version\": version\n                }\n            });\n        }\n        const res = new Response(JSON.stringify(response.body), {\n            status: response.status,\n            headers: {\n                \"x-uploadthing-version\": version\n            }\n        });\n        // @ts-expect-error - this is a custom property\n        res.cleanup = response.cleanup;\n        return res;\n    };\n    const GET = (request)=>{\n        return new Response(JSON.stringify(getBuildPerms()), {\n            status: 200,\n            headers: {\n                \"x-uploadthing-version\": version\n            }\n        });\n    };\n    return {\n        GET,\n        POST\n    };\n};\nconst createRouteHandler = (opts)=>INTERNAL_DO_NOT_USE_createRouteHandlerCore(opts, \"server\");\nconst extractRouterConfig = (router)=>buildPermissionsInfoHandler({\n        router\n    })();\n/**\n * @deprecated Use {@link createRouteHandler} instead\n */ const createServerHandler = createRouteHandler;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXBsb2FkdGhpbmcvc2VydmVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXVSO0FBQ2hPO0FBQ047QUFDTztBQUNpQjtBQUNwQjtBQUNKOztBQUVqRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLElBQUk7QUFDMUM7QUFDQSxzQ0FBc0MsSUFBSTtBQUMxQztBQUNBO0FBQ0Esc0NBQXNDLElBQUk7QUFDMUM7QUFDQSxzQ0FBc0MsSUFBSTtBQUMxQztBQUNBLHNDQUFzQyxJQUFJO0FBQzFDO0FBQ0Esc0NBQXNDLElBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFEQUFnQixXQUFXLDRDQUFPLHNCQUFzQiw0Q0FBTztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkRBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGVBQWUsMkRBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBLCtDQUErQyxNQUFNLEVBQUUsS0FBSyxFQUFFLDJCQUEyQjtBQUN6RjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsbUJBQW1CLG1EQUFTO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG9FQUFlO0FBQzFDLGFBQWEsMkVBQXNCLG9CQUFvQixhQUFhO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHNEQUFzRCxrQkFBa0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQSwwQ0FBMEMsaUNBQWlDO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxnQ0FBZ0MsZ0VBQVc7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Ysa0VBQWtFLGFBQWE7QUFDL0UsbURBQW1ELFlBQVksMkZBQTJGLFlBQVk7QUFDdEs7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EseURBQXlELGFBQWE7QUFDdEUsY0FBYyxpRUFBZ0I7QUFDOUI7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsMkVBQXNCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsd0VBQW1CLFlBQVksK0RBQVU7QUFDOUQ7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpRUFBZ0I7QUFDdEM7QUFDQTtBQUNBLCtFQUErRSxLQUFLO0FBQ3BGLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxrREFBYTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakMsa0VBQWtFLDRDQUFPO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUVBQWdCO0FBQ3ZDO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUSxvQkFBb0IsY0FBYztBQUNwRixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUVBQWdCO0FBQ3ZDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHNFQUFzRSxZQUFZO0FBQ2xGO0FBQ0EsdUJBQXVCLGlFQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLDRFQUE0RSxrQkFBa0I7QUFDOUY7QUFDQSx1QkFBdUIsaUVBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsaUZBQWlGLHVCQUF1QjtBQUN4Ryx1QkFBdUIsaUVBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpRUFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlFQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHVGQUF1Rix5QkFBeUI7QUFDaEg7QUFDQSx1QkFBdUIsaUVBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsS0FBSztBQUM3RDtBQUNBLHVCQUF1QixpRUFBZ0I7QUFDdkM7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHVDQUF1QyxrRUFBYTtBQUNwRDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUVBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLG1DQUFtQyxvRUFBZTtBQUNsRDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUVBQWdCO0FBQzNDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMEVBQWtCO0FBQzlDO0FBQ0Esb0NBQW9DLDBFQUFrQixjQUFjLEVBQUUsMkNBQTJDLFdBQVcsV0FBVztBQUN2STtBQUNBLHVCQUF1QixpRUFBZ0I7QUFDdkM7QUFDQSw4Q0FBOEMsV0FBVztBQUN6RDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxrRUFBYTtBQUMxRDtBQUNBO0FBQ0EsbUNBQW1DLGlFQUFnQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLDRCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQSxtRUFBbUUsNkRBQVE7QUFDM0Usb0VBQW9FLHNDQUFzQyxZQUFZLHNCQUFzQjtBQUM1STtBQUNBLG1DQUFtQyxpRUFBZ0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxtQ0FBbUMsaUVBQWdCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsNkNBQTZDLGlFQUFnQjtBQUM3RCxtQ0FBbUMsaUVBQWdCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLGlDQUFpQywrREFBTyxjQUFjLCtEQUFPO0FBQzdELDhHQUE4RyxTQUFTLCtEQUFPLFVBQVUsZUFBZSxhQUFhO0FBQ3BLO0FBQ0EsbUNBQW1DLGlFQUFnQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELCtEQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMseUVBQW9CO0FBQzNEO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsbUNBQW1DLGlFQUFnQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLCtCQUErQjtBQUMvRDtBQUNBLHdEQUF3RCxPQUFPLGlCQUFpQixLQUFLLG9DQUFvQyxNQUFNO0FBQy9IO0FBQ0EsdUNBQXVDLGlFQUFnQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLG1DQUFtQyxpRUFBZ0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGlEQUFpRCxrRUFBYTtBQUM5RDtBQUNBO0FBQ0EsbUNBQW1DLGlFQUFnQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGtFQUFhO0FBQzVEO0FBQ0E7QUFDQSxtQ0FBbUMsaUVBQWdCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsbUNBQW1DLGlFQUFnQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGtFQUFhO0FBQzVEO0FBQ0E7QUFDQSxtQ0FBbUMsaUVBQWdCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLDRCQUE0QixvQkFBb0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EscURBQXFELGtFQUFhO0FBQ2xFO0FBQ0EsbUNBQW1DLGlFQUFnQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGlFQUFnQjtBQUN2RDtBQUNBLDhEQUE4RCxRQUFRO0FBQ3RFLDZCQUE2QjtBQUM3QjtBQUNBLHlCQUF5QjtBQUN6QixzQkFBc0I7QUFDdEI7QUFDQSxtQ0FBbUMsaUVBQWdCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaUVBQWdCO0FBQy9DO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsdUVBQWtCO0FBQ3hDLE1BQU0sU0FBUyw0Q0FBTztBQUN0QixzQkFBc0IsdUVBQWtCLENBQUMsNENBQU87QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVFQUFrQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIseUVBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsNENBQU87QUFDdEI7QUFDQTtBQUNBLDZCQUE2Qiw0Q0FBTztBQUNwQztBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNENBQU87QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsTUFBTSxHQUFHLE1BQU07QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsSUFBSSw0Q0FBTztBQUNYOztBQUVBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsMkJBQTJCO0FBQzNCLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsdUVBQWtCO0FBQ3JEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpRUFBZ0I7QUFDdEM7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwyRUFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpRUFBZ0I7QUFDbEM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGNBQWMsaUVBQWdCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGlFQUFnQjtBQUNsQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw0Q0FBTyxnQ0FBZ0MsNENBQU87QUFDdEQsY0FBYyxpRUFBZ0I7QUFDOUI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsU0FBUztBQUNUO0FBQ0EsaUNBQWlDLDJFQUFzQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLDRCQUE0QixpRUFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpRUFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGNBQWMsb0VBQWU7QUFDN0IsaUJBQWlCLDJFQUFzQixvQkFBb0IsY0FBYztBQUN6RTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUVBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMkNBQTJDLDJFQUFzQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUVBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywrREFBTTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFtQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHFCQUFxQjtBQUNwRTtBQUNBO0FBQ0Esb0JBQW9CLGdDQUFnQztBQUNwRDtBQUNBLDBCQUEwQiw0REFBTztBQUNqQyxjQUFjO0FBQ2QsMkJBQTJCLDREQUFPO0FBQ2xDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFtQjtBQUNoQztBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsS0FBSyx1SUFBdUk7QUFDcEs7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHdJQUF3SSxFQUFFLHlJQUF5STtBQUMvUztBQUNBO0FBQ0Esb0JBQW9CLGdDQUFnQztBQUNwRDtBQUNBLDBCQUEwQiw0REFBTztBQUNqQyxjQUFjO0FBQ2QsMkJBQTJCLDREQUFPO0FBQ2xDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxvQ0FBb0MsVUFBVTtBQUM5Qyx3QkFBd0IsS0FBSztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDREQUFPO0FBQ2hDLGFBQWE7QUFDYjtBQUNBLDZCQUE2QixtQkFBbUI7QUFDaEQ7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQ0FBZ0M7QUFDcEQ7QUFDQSwwQkFBMEIsaUVBQWdCO0FBQzFDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLDBCQUEwQixpRUFBZ0I7QUFDMUM7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyw0Q0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUVBQWdCO0FBQ3RDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkVBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUVBQWdCO0FBQ3RDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNERBQU87QUFDMUIsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBLHdDQUF3Qyw0REFBTztBQUMvQyxzQkFBc0IsNkRBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsaUVBQWdCLGNBQWMsaUVBQWdCO0FBQzFGO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUZBQW1GLEVBQUUsNkRBQVE7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsaUVBQWdCLGNBQWMsaUVBQWdCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsdUZBQXVGLDREQUFPO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGdDQUFnQyxpRUFBZ0I7QUFDaEQ7QUFDQSx3QkFBd0IsMkVBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDOztBQUVzSiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy91cGxvYWR0aGluZy9zZXJ2ZXIvaW5kZXguanM/NmNmMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc09iamVjdCwgcG9sbEZvckZpbGVEYXRhLCBnZW5lcmF0ZVVwbG9hZFRoaW5nVVJMLCBzaWduUGF5bG9hZCwgVXBsb2FkVGhpbmdFcnJvciwgZmlsbElucHV0Um91dGVDb25maWcsIHNhZmVQYXJzZUpTT04sIHZlcmlmeVNpZ25hdHVyZSwgcmVzb2x2ZU1heWJlVXJsQXJnLCBnZXRUeXBlRnJvbUZpbGVOYW1lLCBvYmplY3RLZXlzLCBjb250ZW50RGlzcG9zaXRpb24sIGFzQXJyYXksIGdldFN0YXR1c0NvZGVGcm9tRXJyb3IgfSBmcm9tICdAdXBsb2FkdGhpbmcvc2hhcmVkJztcbmV4cG9ydCB7IFVwbG9hZFRoaW5nRXJyb3IgfSBmcm9tICdAdXBsb2FkdGhpbmcvc2hhcmVkJztcbmltcG9ydCB7IHByb2Nlc3MsIGlzRGV2ZWxvcG1lbnQgfSBmcm9tICdzdGQtZW52JztcbmltcG9ydCB7IGNyZWF0ZUNvbnNvbGEsIExvZ0xldmVscyB9IGZyb20gJ2NvbnNvbGEvY29yZSc7XG5pbXBvcnQgeyBWQUxJRF9BQ1RJT05fVFlQRVMsIFVURmlsZXMgfSBmcm9tICd1cGxvYWR0aGluZy9pbnRlcm5hbC90eXBlcyc7XG5leHBvcnQgeyBVVEZpbGVzIH0gZnJvbSAndXBsb2FkdGhpbmcvaW50ZXJuYWwvdHlwZXMnO1xuaW1wb3J0IHsgbG9va3VwIH0gZnJvbSAnQHVwbG9hZHRoaW5nL21pbWUtdHlwZXMnO1xuXG52YXIgdmVyc2lvbiA9IFwiNi43LjBcIjtcblxuZnVuY3Rpb24gZGVmYXVsdEVycm9yRm9ybWF0dGVyKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZVxuICAgIH07XG59XG5mdW5jdGlvbiBmb3JtYXRFcnJvcihlcnJvciwgcm91dGVyKSB7XG4gICAgY29uc3QgZXJyb3JGb3JtYXR0ZXIgPSByb3V0ZXJbT2JqZWN0LmtleXMocm91dGVyKVswXV0/Ll9kZWYuZXJyb3JGb3JtYXR0ZXIgPz8gZGVmYXVsdEVycm9yRm9ybWF0dGVyO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVyblxuICAgIHJldHVybiBlcnJvckZvcm1hdHRlcihlcnJvcik7XG59XG5cbmNvbnN0IGNvbG9yaXplID0gKHN0ciwgbGV2ZWwpPT57XG4gICAgLy8gVE9ETzogTWF5YmUgY2hlY2sgaXMgc2hlbGwgc3VwcG9ydHMgY29sb3JzXG4gICAgc3dpdGNoKGxldmVsKXtcbiAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgIGNhc2UgXCJmYXRhbFwiOlxuICAgICAgICAgICAgcmV0dXJuIGBcXHgxYls0MW1cXHgxYlszMG0ke3N0cn1cXHgxYlswbWA7XG4gICAgICAgIGNhc2UgXCJ3YXJuXCI6XG4gICAgICAgICAgICByZXR1cm4gYFxceDFiWzQzbVxceDFiWzMwbSR7c3RyfVxceDFiWzBtYDtcbiAgICAgICAgY2FzZSBcImluZm9cIjpcbiAgICAgICAgY2FzZSBcImxvZ1wiOlxuICAgICAgICAgICAgcmV0dXJuIGBcXHgxYls0NG1cXHgxYlszMG0ke3N0cn1cXHgxYlswbWA7XG4gICAgICAgIGNhc2UgXCJkZWJ1Z1wiOlxuICAgICAgICAgICAgcmV0dXJuIGBcXHgxYls0N21cXHgxYlszMG0ke3N0cn1cXHgxYlswbWA7XG4gICAgICAgIGNhc2UgXCJ0cmFjZVwiOlxuICAgICAgICAgICAgcmV0dXJuIGBcXHgxYls0N21cXHgxYlszMG0ke3N0cn1cXHgxYlswbWA7XG4gICAgICAgIGNhc2UgXCJzdWNjZXNzXCI6XG4gICAgICAgICAgICByZXR1cm4gYFxceDFiWzQybVxceDFiWzMwbSR7c3RyfVxceDFiWzBtYDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxufTtcbmNvbnN0IGljb25zID0ge1xuICAgIGZhdGFsOiBcIuKor1wiLFxuICAgIGVycm9yOiBcIuKor1wiLFxuICAgIHdhcm46IFwi4pqg77iPXCIsXG4gICAgaW5mbzogXCLihLlcIixcbiAgICBsb2c6IFwi4oS5XCIsXG4gICAgZGVidWc6IFwi4pqZXCIsXG4gICAgdHJhY2U6IFwi4oaSXCIsXG4gICAgc3VjY2VzczogXCLinJNcIlxufTtcbmZ1bmN0aW9uIGZvcm1hdFN0YWNrKHN0YWNrKSB7XG4gICAgY29uc3QgY3dkID0gXCJjd2RcIiBpbiBwcm9jZXNzICYmIHR5cGVvZiBwcm9jZXNzLmN3ZCA9PT0gXCJmdW5jdGlvblwiID8gcHJvY2Vzcy5jd2QoKSA6IFwiX19Vbmtub3duQ1dEX19cIjtcbiAgICByZXR1cm4gXCIgIFwiICsgc3RhY2suc3BsaXQoXCJcXG5cIikuc3BsaWNlKDEpLm1hcCgobCk9PmwudHJpbSgpLnJlcGxhY2UoXCJmaWxlOi8vXCIsIFwiXCIpLnJlcGxhY2UoY3dkICsgXCIvXCIsIFwiXCIpKS5qb2luKFwiXFxuICBcIik7XG59XG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcbiAgICBjb25zdCBmbXRBcmdzID0gYXJncy5tYXAoKGFyZyk9PntcbiAgICAgICAgaWYgKGlzT2JqZWN0KGFyZykgJiYgdHlwZW9mIGFyZy5zdGFjayA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIGFyZy5tZXNzYWdlICsgXCJcXG5cIiArIGZvcm1hdFN0YWNrKGFyZy5zdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuXG4gICAgICAgIHJldHVybiBhcmc7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZtdEFyZ3MubWFwKChhcmcpPT57XG4gICAgICAgIGlmICh0eXBlb2YgYXJnID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmcsIG51bGwsIDQpO1xuICAgIH0pO1xufVxuY29uc3QgbG9nZ2VyID0gY3JlYXRlQ29uc29sYSh7XG4gICAgcmVwb3J0ZXJzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxvZzogKGxvZ09iaik9PntcbiAgICAgICAgICAgICAgICBjb25zdCB7IHR5cGUsIHRhZywgZGF0ZSwgYXJncyB9ID0gbG9nT2JqO1xuICAgICAgICAgICAgICAgIGNvbnN0IGljb24gPSBpY29uc1t0eXBlXTtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2dQcmVmaXggPSBjb2xvcml6ZShgICR7aWNvbn0gJHt0YWd9ICR7ZGF0ZS50b0xvY2FsZVRpbWVTdHJpbmcoKX0gYCwgdHlwZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbGluZXMgPSBmb3JtYXRBcmdzKGFyZ3MpLmpvaW4oXCIgXCIpIC8vIGNvbmNhdCBhbGwgYXJndW1lbnRzIHRvIG9uZSBzcGFjZS1zZXBhcmF0ZWQgc3RyaW5nIChsaWtlIGNvbnNvbGUgZG9lcylcbiAgICAgICAgICAgICAgICAuc3BsaXQoXCJcXG5cIikgLy8gc3BsaXQgYWxsIHRoZSBuZXdsaW5lcyAoZS5nLiBmcm9tIGxvZ2dlZCBKU09OLnN0cmluZ2lmaWVkIG9iamVjdHMpXG4gICAgICAgICAgICAgICAgLm1hcCgobCk9PmxvZ1ByZWZpeCArIFwiIFwiICsgbCkgLy8gcHJlcGVuZCB0aGUgbG9nIHByZWZpeCB0byBlYWNoIGxpbmVcbiAgICAgICAgICAgICAgICAuam9pbihcIlxcblwiKTsgLy8gam9pbiBhbGwgdGhlIGxpbmVzIGJhY2sgdG9nZXRoZXJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGxpbmVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0sXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgdGFnOiBcIlVQTE9BRFRISU5HXCJcbiAgICB9XG59KTtcbmNvbnN0IGluaXRMb2dnZXIgPSAobGV2ZWwpPT57XG4gICAgLy8gbG9nZ2VyLndyYXBDb25zb2xlKCk7XG4gICAgbG9nZ2VyLmxldmVsID0gTG9nTGV2ZWxzW2xldmVsID8/IFwiaW5mb1wiXTtcbn07XG5cbmNvbnN0IGlzVmFsaWRSZXNwb25zZSA9IChyZXNwb25zZSk9PntcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA+PSA0MDApIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIXJlc3BvbnNlLmhlYWRlcnMuaGFzKFwieC11cGxvYWR0aGluZy12ZXJzaW9uXCIpKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuY29uc3QgY29uZGl0aW9uYWxEZXZTZXJ2ZXIgPSBhc3luYyAob3B0cyk9PntcbiAgICBjb25zdCBmaWxlRGF0YSA9IGF3YWl0IHBvbGxGb3JGaWxlRGF0YSh7XG4gICAgICAgIHVybDogZ2VuZXJhdGVVcGxvYWRUaGluZ1VSTChgL2FwaS9wb2xsVXBsb2FkLyR7b3B0cy5maWxlS2V5fWApLFxuICAgICAgICBhcGlLZXk6IG9wdHMuYXBpS2V5LFxuICAgICAgICBzZGtWZXJzaW9uOiB2ZXJzaW9uLFxuICAgICAgICBmZXRjaDogb3B0cy5mZXRjaFxuICAgIH0sIGFzeW5jIChqc29uKT0+e1xuICAgICAgICBjb25zdCBmaWxlID0ganNvbi5maWxlRGF0YTtcbiAgICAgICAgbGV0IGNhbGxiYWNrVXJsID0gZmlsZS5jYWxsYmFja1VybCArIGA/c2x1Zz0ke2ZpbGUuY2FsbGJhY2tTbHVnfWA7XG4gICAgICAgIGlmICghY2FsbGJhY2tVcmwuc3RhcnRzV2l0aChcImh0dHBcIikpIGNhbGxiYWNrVXJsID0gXCJodHRwOi8vXCIgKyBjYWxsYmFja1VybDtcbiAgICAgICAgbG9nZ2VyLmluZm8oXCJTSU1VTEFUSU5HIEZJTEUgVVBMT0FEIFdFQkhPT0sgQ0FMTEJBQ0tcIiwgY2FsbGJhY2tVcmwpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgc3RhdHVzOiBcInVwbG9hZGVkXCIsXG4gICAgICAgICAgICBtZXRhZGF0YTogSlNPTi5wYXJzZShmaWxlLm1ldGFkYXRhID8/IFwie31cIiksXG4gICAgICAgICAgICBmaWxlOiB7XG4gICAgICAgICAgICAgICAgdXJsOiBgaHR0cHM6Ly91dGZzLmlvL2YvJHtlbmNvZGVVUklDb21wb25lbnQob3B0cy5maWxlS2V5KX1gLFxuICAgICAgICAgICAgICAgIGtleTogb3B0cy5maWxlS2V5LFxuICAgICAgICAgICAgICAgIG5hbWU6IGZpbGUuZmlsZU5hbWUsXG4gICAgICAgICAgICAgICAgc2l6ZTogZmlsZS5maWxlU2l6ZSxcbiAgICAgICAgICAgICAgICB0eXBlOiBmaWxlLmZpbGVUeXBlLFxuICAgICAgICAgICAgICAgIGN1c3RvbUlkOiBmaWxlLmN1c3RvbUlkXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBzaWduUGF5bG9hZChwYXlsb2FkLCBvcHRzLmFwaUtleSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG9wdHMuZmV0Y2goY2FsbGJhY2tVcmwsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgICAgIGJvZHk6IHBheWxvYWQsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICBcInVwbG9hZHRoaW5nLWhvb2tcIjogXCJjYWxsYmFja1wiLFxuICAgICAgICAgICAgICAgICAgICBcIngtdXBsb2FkdGhpbmctc2lnbmF0dXJlXCI6IHNpZ25hdHVyZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGlzVmFsaWRSZXNwb25zZShyZXNwb25zZSkpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuc3VjY2VzcyhcIlN1Y2Nlc3NmdWxseSBzaW11bGF0ZWQgY2FsbGJhY2sgZm9yIGZpbGVcIiwgb3B0cy5maWxlS2V5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByZXNwb25zZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBGYWlsZWQgdG8gc2ltdWxhdGUgY2FsbGJhY2sgZm9yIGZpbGUgJyR7b3B0cy5maWxlS2V5fScuIElzIHlvdXIgd2ViaG9vayBjb25maWd1cmVkIGNvcnJlY3RseT9gKTtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgICAtIE1ha2Ugc3VyZSB0aGUgVVJMICcke2NhbGxiYWNrVXJsfScgaXMgYWNjZXNzaWJsZSB3aXRob3V0IGFueSBhdXRoZW50aWNhdGlvbi4gWW91IGNhbiB2ZXJpZnkgdGhpcyBieSBydW5uaW5nICdjdXJsIC1YIFBPU1QgJHtjYWxsYmFja1VybH0nIGluIHlvdXIgdGVybWluYWxgKTtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgICAtIFN0aWxsIGZhY2luZyBpc3N1ZXM/IFJlYWQgaHR0cHM6Ly9kb2NzLnVwbG9hZHRoaW5nLmNvbS9mYXEgZm9yIGNvbW1vbiBpc3N1ZXNgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmlsZTtcbiAgICB9KTtcbiAgICBpZiAoZmlsZURhdGEgIT09IHVuZGVmaW5lZCkgcmV0dXJuIGZpbGVEYXRhO1xuICAgIGxvZ2dlci5lcnJvcihgRmFpbGVkIHRvIHNpbXVsYXRlIGNhbGxiYWNrIGZvciBmaWxlICR7b3B0cy5maWxlS2V5fWApO1xuICAgIHRocm93IG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgY29kZTogXCJVUExPQURfRkFJTEVEXCIsXG4gICAgICAgIG1lc3NhZ2U6IFwiRmlsZSB0b29rIHRvbyBsb25nIHRvIHVwbG9hZFwiXG4gICAgfSk7XG59O1xuXG5mdW5jdGlvbiBnZXRQYXJzZUZuKHBhcnNlcikge1xuICAgIGlmICh0eXBlb2YgcGFyc2VyLnBhcnNlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlci5wYXJzZTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwYXJzZXJcIik7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHdyYXBwZWQgZmV0Y2ggdGhhdCB3aWxsIGFsd2F5cyBmb3J3YXJkIGEgZmV3IGhlYWRlcnMgdG8gdGhlIHNlcnZlci5cbiAqLyBjb25zdCBjcmVhdGVVVEZldGNoID0gKGFwaUtleSwgZmV0Y2gsIGZlUGFja2FnZSwgYmVBZGFwdGVyKT0+e1xuICAgIHJldHVybiBhc3luYyAoZW5kcG9pbnQsIHBheWxvYWQpPT57XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goZ2VuZXJhdGVVcGxvYWRUaGluZ1VSTChlbmRwb2ludCksIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwYXlsb2FkKSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICBcIngtdXBsb2FkdGhpbmctYXBpLWtleVwiOiBhcGlLZXksXG4gICAgICAgICAgICAgICAgXCJ4LXVwbG9hZHRoaW5nLXZlcnNpb25cIjogdmVyc2lvbixcbiAgICAgICAgICAgICAgICBcIngtdXBsb2FkdGhpbmctZmUtcGFja2FnZVwiOiBmZVBhY2thZ2UsXG4gICAgICAgICAgICAgICAgXCJ4LXVwbG9hZHRoaW5nLWJlLWFkYXB0ZXJcIjogYmVBZGFwdGVyXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfTtcbn07XG5jb25zdCBmaWxlQ291bnRMaW1pdEhpdCA9IChmaWxlcywgcm91dGVDb25maWcpPT57XG4gICAgY29uc3QgY291bnRzID0ge307XG4gICAgZmlsZXMuZm9yRWFjaCgoZmlsZSk9PntcbiAgICAgICAgY29uc3QgdHlwZSA9IGdldFR5cGVGcm9tRmlsZU5hbWUoZmlsZS5uYW1lLCBvYmplY3RLZXlzKHJvdXRlQ29uZmlnKSk7XG4gICAgICAgIGlmICghY291bnRzW3R5cGVdKSB7XG4gICAgICAgICAgICBjb3VudHNbdHlwZV0gPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY291bnRzW3R5cGVdICs9IDE7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBmb3IoY29uc3QgX2tleSBpbiBjb3VudHMpe1xuICAgICAgICBjb25zdCBrZXkgPSBfa2V5O1xuICAgICAgICBjb25zdCBjb3VudCA9IGNvdW50c1trZXldO1xuICAgICAgICBjb25zdCBsaW1pdCA9IHJvdXRlQ29uZmlnW2tleV0/Lm1heEZpbGVDb3VudDtcbiAgICAgICAgaWYgKCFsaW1pdCkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKHJvdXRlQ29uZmlnLCBrZXkpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICAgICAgICAgIGNvZGU6IFwiQkFEX1JFUVVFU1RcIixcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIkludmFsaWQgY29uZmlnIGR1cmluZyBmaWxlIGNvdW50XCIsXG4gICAgICAgICAgICAgICAgY2F1c2U6IGBFeHBlY3RlZCByb3V0ZSBjb25maWcgdG8gaGF2ZSBhIG1heEZpbGVDb3VudCBmb3Iga2V5ICR7a2V5fSBidXQgbm9uZSB3YXMgZm91bmQuYFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvdW50ID4gbGltaXQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbGltaXRIaXQ6IHRydWUsXG4gICAgICAgICAgICAgICAgdHlwZToga2V5LFxuICAgICAgICAgICAgICAgIGxpbWl0LFxuICAgICAgICAgICAgICAgIGNvdW50XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGxpbWl0SGl0OiBmYWxzZVxuICAgIH07XG59O1xuY29uc3QgYnVpbGRSZXF1ZXN0SGFuZGxlciA9IChvcHRzLCBhZGFwdGVyKT0+e1xuICAgIHJldHVybiBhc3luYyAoaW5wdXQpPT57XG4gICAgICAgIGNvbnN0IGlzRGV2ID0gb3B0cy5jb25maWc/LmlzRGV2ID8/IGlzRGV2ZWxvcG1lbnQ7XG4gICAgICAgIGNvbnN0IGZldGNoID0gb3B0cy5jb25maWc/LmZldGNoID8/IGdsb2JhbFRoaXMuZmV0Y2g7XG4gICAgICAgIGlmIChpc0Rldikge1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oXCJVcGxvYWRUaGluZyBkZXYgc2VydmVyIGlzIG5vdyBydW5uaW5nIVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHJvdXRlciwgY29uZmlnIH0gPSBvcHRzO1xuICAgICAgICBjb25zdCBwcmVmZXJyZWRPckVudlNlY3JldCA9IGNvbmZpZz8udXBsb2FkdGhpbmdTZWNyZXQgPz8gcHJvY2Vzcy5lbnYuVVBMT0FEVEhJTkdfU0VDUkVUO1xuICAgICAgICBjb25zdCByZXEgPSBpbnB1dC5yZXE7XG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwocmVxLnVybCk7XG4gICAgICAgIC8vIEdldCBpbnB1dHMgZnJvbSBxdWVyeSBhbmQgcGFyYW1zXG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHVybC5zZWFyY2hQYXJhbXM7XG4gICAgICAgIGNvbnN0IHVwbG9hZHRoaW5nSG9vayA9IHJlcS5oZWFkZXJzLmdldChcInVwbG9hZHRoaW5nLWhvb2tcIikgPz8gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBzbHVnID0gcGFyYW1zLmdldChcInNsdWdcIikgPz8gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBhY3Rpb25UeXBlID0gcGFyYW1zLmdldChcImFjdGlvblR5cGVcIikgPz8gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCB1dEZyb250ZW5kUGFja2FnZSA9IHJlcS5oZWFkZXJzLmdldChcIngtdXBsb2FkdGhpbmctcGFja2FnZVwiKSA/PyBcInVua25vd25cIjtcbiAgICAgICAgY29uc3QgY2xpZW50VmVyc2lvbiA9IHJlcS5oZWFkZXJzLmdldChcIngtdXBsb2FkdGhpbmctdmVyc2lvblwiKTtcbiAgICAgICAgaWYgKGNsaWVudFZlcnNpb24gIT0gbnVsbCAmJiBjbGllbnRWZXJzaW9uICE9PSB2ZXJzaW9uKSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJDbGllbnQgdmVyc2lvbiBtaXNtYXRjaFwiKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICAgICAgY29kZTogXCJCQURfUkVRVUVTVFwiLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiQ2xpZW50IHZlcnNpb24gbWlzbWF0Y2hcIixcbiAgICAgICAgICAgICAgICBjYXVzZTogYFNlcnZlciB2ZXJzaW9uOiAke3ZlcnNpb259LCBDbGllbnQgdmVyc2lvbjogJHtjbGllbnRWZXJzaW9ufWBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFZhbGlkYXRlIGlucHV0c1xuICAgICAgICBpZiAoIXNsdWcpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIk5vIHNsdWcgcHJvdmlkZWQgaW4gcGFyYW1zOlwiLCBwYXJhbXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIkJBRF9SRVFVRVNUXCIsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCJObyBzbHVnIHByb3ZpZGVkIGluIHBhcmFtc1wiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2x1ZyAmJiB0eXBlb2Ygc2x1ZyAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gYEV4cGVjdGVkIHNsdWcgdG8gYmUgb2YgdHlwZSAnc3RyaW5nJywgZ290ICcke3R5cGVvZiBzbHVnfSdgO1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKG1zZyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICAgICAgICAgIGNvZGU6IFwiQkFEX1JFUVVFU1RcIixcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBcImBzbHVnYCBtdXN0IGJlIGEgc3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgY2F1c2U6IG1zZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjdGlvblR5cGUgJiYgdHlwZW9mIGFjdGlvblR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IGBFeHBlY3RlZCBhY3Rpb25UeXBlIHRvIGJlIG9mIHR5cGUgJ3N0cmluZycsIGdvdCAnJHt0eXBlb2YgYWN0aW9uVHlwZX0nYDtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihtc2cpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIkJBRF9SRVFVRVNUXCIsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCJgYWN0aW9uVHlwZWAgbXVzdCBiZSBhIHN0cmluZ1wiLFxuICAgICAgICAgICAgICAgIGNhdXNlOiBtc2dcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGxvYWR0aGluZ0hvb2sgJiYgdHlwZW9mIHVwbG9hZHRoaW5nSG9vayAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gYEV4cGVjdGVkIHVwbG9hZHRoaW5nSG9vayB0byBiZSBvZiB0eXBlICdzdHJpbmcnLCBnb3QgJyR7dHlwZW9mIHVwbG9hZHRoaW5nSG9va30nYDtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICAgICAgY29kZTogXCJCQURfUkVRVUVTVFwiLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiYHVwbG9hZHRoaW5nSG9va2AgbXVzdCBiZSBhIHN0cmluZ1wiLFxuICAgICAgICAgICAgICAgIGNhdXNlOiBtc2dcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcHJlZmVycmVkT3JFbnZTZWNyZXQpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IGBObyBzZWNyZXQgcHJvdmlkZWQsIHBsZWFzZSBzZXQgVVBMT0FEVEhJTkdfU0VDUkVUIGluIHlvdXIgZW52IGZpbGUgb3IgaW4gdGhlIGNvbmZpZ2A7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IobXNnKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICAgICAgY29kZTogXCJNSVNTSU5HX0VOVlwiLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBObyBzZWNyZXQgcHJvdmlkZWRgLFxuICAgICAgICAgICAgICAgIGNhdXNlOiBtc2dcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcHJlZmVycmVkT3JFbnZTZWNyZXQuc3RhcnRzV2l0aChcInNrX1wiKSkge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gYEludmFsaWQgc2VjcmV0IHByb3ZpZGVkLCBVUExPQURUSElOR19TRUNSRVQgbXVzdCBzdGFydCB3aXRoICdza18nYDtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihtc2cpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIk1JU1NJTkdfRU5WXCIsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCJJbnZhbGlkIEFQSSBrZXkuIEFQSSBrZXlzIG11c3Qgc3RhcnQgd2l0aCAnc2tfJy5cIixcbiAgICAgICAgICAgICAgICBjYXVzZTogbXNnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXRGcm9udGVuZFBhY2thZ2UgJiYgdHlwZW9mIHV0RnJvbnRlbmRQYWNrYWdlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSBgRXhwZWN0ZWQgeC11cGxvYWR0aGluZy1wYWNrYWdlIHRvIGJlIG9mIHR5cGUgJ3N0cmluZycsIGdvdCAnJHt0eXBlb2YgdXRGcm9udGVuZFBhY2thZ2V9J2A7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IobXNnKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICAgICAgY29kZTogXCJCQURfUkVRVUVTVFwiLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiYHgtdXBsb2FkdGhpbmctcGFja2FnZWAgbXVzdCBiZSBhIHN0cmluZy4gZWcuICdAdXBsb2FkdGhpbmcvcmVhY3QnXCIsXG4gICAgICAgICAgICAgICAgY2F1c2U6IG1zZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXBsb2FkYWJsZSA9IHJvdXRlcltzbHVnXTtcbiAgICAgICAgaWYgKCF1cGxvYWRhYmxlKSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSBgTm8gZmlsZSByb3V0ZSBmb3VuZCBmb3Igc2x1ZyAke3NsdWd9YDtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihtc2cpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIk5PVF9GT1VORFwiLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1zZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXRGZXRjaCA9IGNyZWF0ZVVURmV0Y2gocHJlZmVycmVkT3JFbnZTZWNyZXQsIGZldGNoLCB1dEZyb250ZW5kUGFja2FnZSwgYWRhcHRlcik7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcIkFsbCByZXF1ZXN0IGlucHV0IGlzIHZhbGlkXCIsIHtcbiAgICAgICAgICAgIHNsdWcsXG4gICAgICAgICAgICBhY3Rpb25UeXBlLFxuICAgICAgICAgICAgdXBsb2FkdGhpbmdIb29rXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodXBsb2FkdGhpbmdIb29rID09PSBcImNhbGxiYWNrXCIpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgd2hlbiB3ZSByZWNlaXZlIHRoZSB3ZWJob29rIGZyb20gdXBsb2FkdGhpbmdcbiAgICAgICAgICAgIGNvbnN0IG1heWJlUmVxQm9keSA9IGF3YWl0IHNhZmVQYXJzZUpTT04ocmVxKTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIkhhbmRsaW5nIGNhbGxiYWNrIHJlcXVlc3Qgd2l0aCBpbnB1dDpcIiwgbWF5YmVSZXFCb2R5KTtcbiAgICAgICAgICAgIGlmIChtYXliZVJlcUJvZHkgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIkludmFsaWQgcmVxdWVzdCBib2R5XCIsIG1heWJlUmVxQm9keSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogXCJCQURfUkVRVUVTVFwiLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIkludmFsaWQgcmVxdWVzdCBib2R5XCIsXG4gICAgICAgICAgICAgICAgICAgIGNhdXNlOiBtYXliZVJlcUJvZHlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHZlcmlmaWVkID0gYXdhaXQgdmVyaWZ5U2lnbmF0dXJlKEpTT04uc3RyaW5naWZ5KG1heWJlUmVxQm9keSksIHJlcS5oZWFkZXJzLmdldChcIngtdXBsb2FkdGhpbmctc2lnbmF0dXJlXCIpLCBwcmVmZXJyZWRPckVudlNlY3JldCk7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJTaWduYXR1cmUgdmVyaWZpZWQ6XCIsIHZlcmlmaWVkKTtcbiAgICAgICAgICAgIGlmICghdmVyaWZpZWQpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJJbnZhbGlkIHNpZ25hdHVyZVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIkJBRF9SRVFVRVNUXCIsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiSW52YWxpZCBzaWduYXR1cmVcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXJBcmdzID0ge1xuICAgICAgICAgICAgICAgIGZpbGU6IG1heWJlUmVxQm9keS5maWxlLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBtYXliZVJlcUJvZHkubWV0YWRhdGFcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJSdW5uaW5nICdvblVwbG9hZENvbXBsZXRlJyBjYWxsYmFjayB3aXRoIGlucHV0OlwiLCByZXNvbHZlckFyZ3MpO1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdXBsb2FkYWJsZS5yZXNvbHZlcihyZXNvbHZlckFyZ3MpO1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICBmaWxlS2V5OiBtYXliZVJlcUJvZHkuZmlsZS5rZXksXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tEYXRhOiByZXMgPz8gbnVsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIidvblVwbG9hZENvbXBsZXRlJyBjYWxsYmFjayBmaW5pc2hlZC4gU2VuZGluZyByZXNwb25zZSB0byBVcGxvYWRUaGluZzpcIiwgcGF5bG9hZCk7XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFja1Jlc3BvbnNlID0gYXdhaXQgdXRGZXRjaChcIi9hcGkvc2VydmVyQ2FsbGJhY2tcIiwgcGF5bG9hZCk7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJVcGxvYWRUaGluZyByZXNwb25kZWQgd2l0aCBzdGF0dXM6XCIsIGNhbGxiYWNrUmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiAyMDAsXG4gICAgICAgICAgICAgICAgYm9keTogbnVsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFjdGlvblR5cGUgfHwgIVZBTElEX0FDVElPTl9UWVBFUy5pbmNsdWRlcyhhY3Rpb25UeXBlKSkge1xuICAgICAgICAgICAgLy8gVGhpcyB3b3VsZCBlaXRoZXIgYmUgc29tZW9uZSBzcGFtbWluZyBvciB0aGUgQVdTIHdlYmhvb2tcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IGBFeHBlY3RlZCAke1ZBTElEX0FDVElPTl9UWVBFUy5tYXAoKHgpPT5gXCIke3h9XCJgKS5qb2luKFwiLCBcIikucmVwbGFjZSgvLCg/IS4qLCkvLCBcIiBvclwiKX0gYnV0IGdvdCBcIiR7YWN0aW9uVHlwZX1cImA7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJJbnZhbGlkIGFjdGlvbiB0eXBlLlwiLCBtc2cpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIkJBRF9SRVFVRVNUXCIsXG4gICAgICAgICAgICAgICAgY2F1c2U6IGBJbnZhbGlkIGFjdGlvbiB0eXBlICR7YWN0aW9uVHlwZX1gLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1zZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoKGFjdGlvblR5cGUpe1xuICAgICAgICAgICAgY2FzZSBcInVwbG9hZFwiOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF5YmVJbnB1dCA9IGF3YWl0IHNhZmVQYXJzZUpTT04ocmVxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heWJlSW5wdXQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiSW52YWxpZCByZXF1ZXN0IGJvZHlcIiwgbWF5YmVJbnB1dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiQkFEX1JFUVVFU1RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIkludmFsaWQgcmVxdWVzdCBib2R5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F1c2U6IG1heWJlSW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIkhhbmRsaW5nIHVwbG9hZCByZXF1ZXN0IHdpdGggaW5wdXQ6XCIsIG1heWJlSW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGZpbGVzLCBpbnB1dDogdXNlcklucHV0IH0gPSBtYXliZUlucHV0O1xuICAgICAgICAgICAgICAgICAgICAvLyBWYWxpZGF0ZSB3aXRob3V0IFpvZCAoZm9yIG5vdylcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGZpbGVzKSB8fCAhZmlsZXMuZXZlcnkoKGYpPT5pc09iamVjdChmKSAmJiB0eXBlb2YgZi5uYW1lID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBmLnNpemUgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIGYudHlwZSA9PT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1zZyA9IGBFeHBlY3RlZCBmaWxlcyB0byBiZSBvZiB0eXBlICd7bmFtZTpzdHJpbmcsIHNpemU6bnVtYmVyLCB0eXBlOnN0cmluZ31bXScsIGdvdCAnJHtKU09OLnN0cmluZ2lmeShmaWxlcyl9J2A7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IobXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJCQURfUkVRVUVTVFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiRmlsZXMgbXVzdCBiZSBhbiBhcnJheSBvZiBvYmplY3RzIHdpdGggbmFtZSBhbmQgc2l6ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdXNlOiBtc2dcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHZhbGlkYXRlIHRoZSBpbnB1dFxuICAgICAgICAgICAgICAgICAgICBsZXQgcGFyc2VkSW5wdXQgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIlBhcnNpbmcgaW5wdXRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnB1dFBhcnNlciA9IHVwbG9hZGFibGUuX2RlZi5pbnB1dFBhcnNlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZElucHV0ID0gYXdhaXQgZ2V0UGFyc2VGbihpbnB1dFBhcnNlcikodXNlcklucHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIklucHV0IHBhcnNlZCBzdWNjZXNzZnVsbHlcIiwgcGFyc2VkSW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiQW4gZXJyb3Igb2NjdXJyZWQgdHJ5aW5nIHRvIHBhcnNlIGlucHV0OlwiLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiQkFEX1JFUVVFU1RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIkludmFsaWQgaW5wdXQuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F1c2U6IGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgbWV0YWRhdGEgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIlJ1bm5pbmcgbWlkZGxld2FyZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhID0gYXdhaXQgdXBsb2FkYWJsZS5fZGVmLm1pZGRsZXdhcmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmlucHV0Lm1pZGRsZXdhcmVBcmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0OiBwYXJzZWRJbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlc1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJNaWRkbGV3YXJlIGZpbmlzaGVkIHN1Y2Nlc3NmdWxseSB3aXRoOlwiLCBtZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJBbiBlcnJvciBvY2N1cnJlZCBpbiB5b3VyIG1pZGRsZXdhcmUgZnVuY3Rpb246XCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFVwbG9hZFRoaW5nRXJyb3IpIHJldHVybiBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJJTlRFUk5BTF9TRVJWRVJfRVJST1JcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIkZhaWxlZCB0byBydW4gbWlkZGxld2FyZS5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXVzZTogZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRhZGF0YVtVVEZpbGVzXSAmJiBtZXRhZGF0YVtVVEZpbGVzXS5sZW5ndGggIT09IGZpbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbXNnID0gYEV4cGVjdGVkIGZpbGVzIG92ZXJyaWRlIHRvIGhhdmUgdGhlIHNhbWUgbGVuZ3RoIGFzIG9yaWdpbmFsIGZpbGVzLCBnb3QgJHttZXRhZGF0YVtVVEZpbGVzXS5sZW5ndGh9IGJ1dCBleHBlY3RlZCAke2ZpbGVzLmxlbmd0aH1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKG1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiQkFEX1JFUVVFU1RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIkZpbGVzIG92ZXJyaWRlIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGggYXMgZmlsZXNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXVzZTogbXNnXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBBdHRhY2ggY3VzdG9tSWRzIGZyb20gbWlkZGxld2FyZSB0byB0aGUgZmlsZXNcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlsZXNXaXRoQ3VzdG9tSWRzID0gZmlsZXMubWFwKChmaWxlLCBpZHgpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0aGVpcnMgPSBtZXRhZGF0YVtVVEZpbGVzXT8uW2lkeF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhlaXJzICYmIHRoZWlycy5zaXplICE9PSBmaWxlLnNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihcIkZpbGUgc2l6ZSBtaXNtYXRjaC4gUmV2ZXJ0aW5nIHRvIG9yaWdpbmFsIHNpemVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHRoZWlycz8ubmFtZSA/PyBmaWxlLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogZmlsZS5zaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1c3RvbUlkOiB0aGVpcnM/LmN1c3RvbUlkXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRklMTCBUSEUgUk9VVEUgQ09ORklHIHNvIHRoZSBzZXJ2ZXIgb25seSBoYXMgb25lIGhhcHB5IHBhdGhcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBhcnNlZENvbmZpZztcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIlBhcnNpbmcgcm91dGUgY29uZmlnXCIsIHVwbG9hZGFibGUuX2RlZi5yb3V0ZXJDb25maWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkQ29uZmlnID0gZmlsbElucHV0Um91dGVDb25maWcodXBsb2FkYWJsZS5fZGVmLnJvdXRlckNvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJSb3V0ZSBjb25maWcgcGFyc2VkIHN1Y2Nlc3NmdWxseVwiLCBwYXJzZWRDb25maWcpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiSW52YWxpZCByb3V0ZSBjb25maWdcIiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIkJBRF9SRVFVRVNUXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJJbnZhbGlkIGNvbmZpZy5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXVzZTogZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJDaGVja2luZyBmaWxlIGNvdW50IGxpbWl0XCIsIGZpbGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgbGltaXRIaXQsIGNvdW50LCBsaW1pdCwgdHlwZSB9ID0gZmlsZUNvdW50TGltaXRIaXQoZmlsZXMsIHBhcnNlZENvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGltaXRIaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSBgWW91IHVwbG9hZGVkICR7Y291bnR9IGZpbGVzIG9mIHR5cGUgJyR7dHlwZX0nLCBidXQgdGhlIGxpbWl0IGZvciB0aGF0IHR5cGUgaXMgJHtsaW1pdH1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihtc2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiQkFEX1JFUVVFU1RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJGaWxlIGxpbWl0IGV4Y2VlZGVkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdXNlOiBtc2dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIkZpbGUgY291bnQgbGltaXQgY2hlY2sgcGFzc2VkXCIpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiSW52YWxpZCByb3V0ZSBjb25maWdcIiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIkJBRF9SRVFVRVNUXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJJbnZhbGlkIGNvbmZpZy5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXVzZTogZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrVXJsID0gcmVzb2x2ZUNhbGxiYWNrVXJsKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRGV2XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJSZXRyaWV2aW5nIHByZXNpZ25lZCBVUkxzIGZyb20gVXBsb2FkVGhpbmcuIENhbGxiYWNrIFVSTCBpczpcIiwgY2FsbGJhY2tVcmwuaHJlZik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVwbG9hZHRoaW5nQXBpUmVzcG9uc2UgPSBhd2FpdCB1dEZldGNoKFwiL2FwaS9wcmVwYXJlVXBsb2FkXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVzOiBmaWxlc1dpdGhDdXN0b21JZHMsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZUNvbmZpZzogcGFyc2VkQ29uZmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja1VybDogY2FsbGJhY2tVcmwub3JpZ2luICsgY2FsbGJhY2tVcmwucGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja1NsdWc6IHNsdWdcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgd2hlbiB3ZSBzZW5kIHRoZSByZXNwb25zZSBiYWNrIHRvIHRoZSB1c2VyJ3MgZm9ybSBzbyB0aGV5IGNhbiBzdWJtaXQgdGhlIGZpbGVzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZFJlc3BvbnNlID0gYXdhaXQgc2FmZVBhcnNlSlNPTih1cGxvYWR0aGluZ0FwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF1cGxvYWR0aGluZ0FwaVJlc3BvbnNlLm9rIHx8IHBhcnNlZFJlc3BvbnNlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIlVuYWJsZSB0byBnZXQgcHJlc2lnbmVkIFVSTHNcIiwgcGFyc2VkUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIlVSTF9HRU5FUkFUSU9OX0ZBSUxFRFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiVW5hYmxlIHRvIGdldCBwcmVzaWduZWQgdXJsc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdXNlOiBwYXJzZWRSZXNwb25zZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiVXBsb2FkVGhpbmcgcmVzcG9uZGVkIHdpdGg6XCIsIHBhcnNlZFJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiU2VuZGluZyBwcmVzaWduZWQgVVJMcyB0byBjbGllbnRcIik7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgd2hlbiB3ZSBzZW5kIHRoZSByZXNwb25zZSBiYWNrIHRvIHRoZSB1c2VyJ3MgZm9ybSBzbyB0aGV5IGNhbiBzdWJtaXQgdGhlIGZpbGVzXG4gICAgICAgICAgICAgICAgICAgIGxldCBwcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNEZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UgPSBQcm9taXNlLmFsbChwYXJzZWRSZXNwb25zZS5tYXAoKGZpbGUpPT5jb25kaXRpb25hbERldlNlcnZlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVLZXk6IGZpbGUua2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcGlLZXk6IHByZWZlcnJlZE9yRW52U2VjcmV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKChlcnJvcik9PntcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiRXJyXCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhbnVwOiBwcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogcGFyc2VkUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IDIwMFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJtdWx0aXBhcnQtY29tcGxldGVcIjpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1heWJlUmVxQm9keSA9IGF3YWl0IHNhZmVQYXJzZUpTT04ocmVxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heWJlUmVxQm9keSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJJbnZhbGlkIHJlcXVlc3QgYm9keVwiLCBtYXliZVJlcUJvZHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIkJBRF9SRVFVRVNUXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJJbnZhbGlkIHJlcXVlc3QgYm9keVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdXNlOiBtYXliZVJlcUJvZHlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIkhhbmRsaW5nIG11bHRpcGFydC1jb21wbGV0ZSByZXF1ZXN0IHdpdGggaW5wdXQ6XCIsIG1heWJlUmVxQm9keSk7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIk5vdGlmeWluZyBVcGxvYWRUaGluZyB0aGF0IG11bHRpcGFydCB1cGxvYWQgaXMgY29tcGxldGVcIik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBsZXRlUmVzID0gYXdhaXQgdXRGZXRjaChcIi9hcGkvY29tcGxldGVNdWx0aXBhcnRcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZUtleTogbWF5YmVSZXFCb2R5LmZpbGVLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGxvYWRJZDogbWF5YmVSZXFCb2R5LnVwbG9hZElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXRhZ3M6IG1heWJlUmVxQm9keS5ldGFnc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb21wbGV0ZVJlcy5vaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIG5vdGlmeSBVcGxvYWRUaGluZyB0aGF0IG11bHRpcGFydCB1cGxvYWQgaXMgY29tcGxldGVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiVVBMT0FEX0ZBSUxFRFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiRmFpbGVkIHRvIGNvbXBsZXRlIG11bHRpcGFydCB1cGxvYWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXVzZTogY29tcGxldGVSZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIlVwbG9hZFRoaW5nIHJlc3BvbmRlZCB3aXRoOlwiLCBjb21wbGV0ZVJlcy5zdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiAyMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBudWxsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImZhaWx1cmVcIjpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1heWJlUmVxQm9keSA9IGF3YWl0IHNhZmVQYXJzZUpTT04ocmVxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heWJlUmVxQm9keSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJJbnZhbGlkIHJlcXVlc3QgYm9keVwiLCBtYXliZVJlcUJvZHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIkJBRF9SRVFVRVNUXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJJbnZhbGlkIHJlcXVlc3QgYm9keVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdXNlOiBtYXliZVJlcUJvZHlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZmlsZUtleSwgdXBsb2FkSWQgfSA9IG1heWJlUmVxQm9keTtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiSGFuZGxpbmcgZmFpbHVyZSByZXF1ZXN0IHdpdGggaW5wdXQ6XCIsIG1heWJlUmVxQm9keSk7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIk5vdGlmeWluZyBVcGxvYWRUaGluZyB0aGF0IHVwbG9hZCBmYWlsZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRlbGwgdXBsb2FkdGhpbmcgdG8gbWFyayB0aGUgdXBsb2FkIGFzIGZhaWxlZFxuICAgICAgICAgICAgICAgICAgICBjb25zdCB1cGxvYWR0aGluZ0FwaVJlc3BvbnNlID0gYXdhaXQgdXRGZXRjaChcIi9hcGkvZmFpbHVyZUNhbGxiYWNrXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGxvYWRJZFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF1cGxvYWR0aGluZ0FwaVJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRSZXNwb25zZSA9IGF3YWl0IHNhZmVQYXJzZUpTT04odXBsb2FkdGhpbmdBcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJGYWlsZWQgdG8gbWFyayB1cGxvYWQgYXMgZmFpbGVkXCIsIHBhcnNlZFJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJJTlRFUk5BTF9TRVJWRVJfRVJST1JcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIlVuYWJsZSB0byBtYXJrIHVwbG9hZCBhcyBmYWlsZWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXVzZTogcGFyc2VkUmVzcG9uc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIlVwbG9hZFRoaW5nIHJlc3BvbmRlZCB3aXRoOlwiLCB1cGxvYWR0aGluZ0FwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiUnVubmluZyAnb25VcGxvYWRFcnJvcicgY2FsbGJhY2tcIik7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSdW4gdGhlIG9uVXBsb2FkRXJyb3IgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwbG9hZGFibGUuX2RlZi5vblVwbG9hZEVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogbmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIlVQTE9BRF9GQUlMRURcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYFVwbG9hZCBmYWlsZWQgZm9yICR7ZmlsZUtleX1gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZUtleVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJGYWlsZWQgdG8gcnVuIG9uVXBsb2FkRXJyb3IgY2FsbGJhY2suIFlvdSBwcm9iYWJseSBzaG91bGRuJ3QgYmUgdGhyb3dpbmcgZXJyb3JzIGluIHlvdXIgY2FsbGJhY2suXCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJJTlRFUk5BTF9TRVJWRVJfRVJST1JcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIkZhaWxlZCB0byBydW4gb25VcGxvYWRFcnJvciBjYWxsYmFja1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdXNlOiBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogMjAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogbnVsbFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiQkFEX1JFUVVFU1RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBJbnZhbGlkIGFjdGlvbiB0eXBlYFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufTtcbmZ1bmN0aW9uIHJlc29sdmVDYWxsYmFja1VybChvcHRzKSB7XG4gICAgbGV0IGNhbGxiYWNrVXJsID0gb3B0cy51cmw7XG4gICAgaWYgKG9wdHMuY29uZmlnPy5jYWxsYmFja1VybCkge1xuICAgICAgICBjYWxsYmFja1VybCA9IHJlc29sdmVNYXliZVVybEFyZyhvcHRzLmNvbmZpZy5jYWxsYmFja1VybCk7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5VUExPQURUSElOR19VUkwpIHtcbiAgICAgICAgY2FsbGJhY2tVcmwgPSByZXNvbHZlTWF5YmVVcmxBcmcocHJvY2Vzcy5lbnYuVVBMT0FEVEhJTkdfVVJMKTtcbiAgICB9XG4gICAgaWYgKG9wdHMuaXNEZXYgfHwgIWNhbGxiYWNrVXJsLmhvc3QuaW5jbHVkZXMoXCJsb2NhbGhvc3RcIikpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrVXJsO1xuICAgIH1cbiAgICAvLyBQcm9kdWN0aW9uIGJ1aWxkcyBoYXZlIHRvIGhhdmUgYSBwdWJsaWMgVVJMIHNvIFVUIGNhbiBzZW5kIHdlYmhvb2tcbiAgICAvLyBQYXJzZSB0aGUgVVJMIGZyb20gdGhlIGhlYWRlcnNcbiAgICBjb25zdCBoZWFkZXJzID0gb3B0cy5yZXEuaGVhZGVycztcbiAgICBsZXQgcGFyc2VkRnJvbUhlYWRlcnMgPSBoZWFkZXJzLmdldChcIm9yaWdpblwiKSA/PyBoZWFkZXJzLmdldChcInJlZmVyZXJcIikgPz8gaGVhZGVycy5nZXQoXCJob3N0XCIpID8/IGhlYWRlcnMuZ2V0KFwieC1mb3J3YXJkZWQtaG9zdFwiKTtcbiAgICBpZiAocGFyc2VkRnJvbUhlYWRlcnMgJiYgIXBhcnNlZEZyb21IZWFkZXJzLmluY2x1ZGVzKFwiaHR0cFwiKSkge1xuICAgICAgICBwYXJzZWRGcm9tSGVhZGVycyA9IChoZWFkZXJzLmdldChcIngtZm9yd2FyZGVkLXByb3RvXCIpID8/IFwiaHR0cHNcIikgKyBcIjovL1wiICsgcGFyc2VkRnJvbUhlYWRlcnM7XG4gICAgfVxuICAgIGlmICghcGFyc2VkRnJvbUhlYWRlcnMgfHwgcGFyc2VkRnJvbUhlYWRlcnMuaW5jbHVkZXMoXCJsb2NhbGhvc3RcIikpIHtcbiAgICAgICAgLy8gRGlkbid0IGZpbmQgYSB2YWxpZCBVUkwgaW4gdGhlIGhlYWRlcnMsIGxvZyBhIHdhcm5pbmcgYW5kIHVzZSB0aGUgb3JpZ2luYWwgdXJsIGFueXdheVxuICAgICAgICBsb2dnZXIud2FybihcIllvdSBhcmUgdXNpbmcgYSBsb2NhbGhvc3QgY2FsbGJhY2sgdXJsIGluIHByb2R1Y3Rpb24gd2hpY2ggaXMgbm90IHN1cHBvcnRlZC5cIiwgXCJSZWFkIG1vcmUgYW5kIGxlYXJuIGhvdyB0byBmaXggaXQgaGVyZTogaHR0cHM6Ly9kb2NzLnVwbG9hZHRoaW5nLmNvbS9mYXEjbXktY2FsbGJhY2stcnVucy1pbi1kZXZlbG9wbWVudC1idXQtbm90LWluLXByb2R1Y3Rpb25cIik7XG4gICAgICAgIHJldHVybiBjYWxsYmFja1VybDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc29sdmVNYXliZVVybEFyZyhwYXJzZWRGcm9tSGVhZGVycyk7XG59XG5jb25zdCBidWlsZFBlcm1pc3Npb25zSW5mb0hhbmRsZXIgPSAob3B0cyk9PntcbiAgICByZXR1cm4gKCk9PntcbiAgICAgICAgY29uc3QgciA9IG9wdHMucm91dGVyO1xuICAgICAgICBjb25zdCBwZXJtaXNzaW9ucyA9IE9iamVjdC5rZXlzKHIpLm1hcCgoayk9PntcbiAgICAgICAgICAgIGNvbnN0IHJvdXRlID0gcltrXTtcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IGZpbGxJbnB1dFJvdXRlQ29uZmlnKHJvdXRlLl9kZWYucm91dGVyQ29uZmlnKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2x1ZzogayxcbiAgICAgICAgICAgICAgICBjb25maWdcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGVybWlzc2lvbnM7XG4gICAgfTtcbn07XG5cbmZ1bmN0aW9uIGluY29tcGF0aWJsZU5vZGVHdWFyZCgpIHtcbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybjtcbiAgICBsZXQgbWFqb3I7XG4gICAgbGV0IG1pbm9yO1xuICAgIGNvbnN0IG1heWJlTm9kZVZlcnNpb24gPSBwcm9jZXNzLnZlcnNpb25zPy5ub2RlPy5zcGxpdChcIi5cIik7XG4gICAgaWYgKG1heWJlTm9kZVZlcnNpb24pIHtcbiAgICAgICAgW21ham9yLCBtaW5vcl0gPSBtYXliZU5vZGVWZXJzaW9uLm1hcCgodik9PnBhcnNlSW50KHYsIDEwKSk7XG4gICAgfVxuICAgIGNvbnN0IG1heWJlTm9kZVBhdGggPSBwcm9jZXNzLmVudj8uTk9ERTtcbiAgICBpZiAoIW1ham9yICYmIG1heWJlTm9kZVBhdGgpIHtcbiAgICAgICAgY29uc3Qgbm9kZVZlcnNpb24gPSAvdihcXGQrKVxcLihcXGQrKVxcLihcXGQrKS8uZXhlYyhtYXliZU5vZGVQYXRoKT8uWzBdO1xuICAgICAgICBpZiAobm9kZVZlcnNpb24pIHtcbiAgICAgICAgICAgIFttYWpvciwgbWlub3JdID0gbm9kZVZlcnNpb24uc3Vic3RyaW5nKDEpLnNwbGl0KFwiLlwiKS5tYXAoKHYpPT5wYXJzZUludCh2LCAxMCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghbWFqb3IgfHwgIW1pbm9yKSByZXR1cm47XG4gICAgLy8gUmVxdWlyZSBeMTguMTMuMFxuICAgIGlmIChtYWpvciA+IDE4KSByZXR1cm47XG4gICAgaWYgKG1ham9yID09PSAxOCAmJiBtaW5vciA+PSAxMykgcmV0dXJuO1xuICAgIGxvZ2dlci5mYXRhbChgWU9VIEFSRSBVU0lORyBBIExFR0FDWSAoJHttYWpvcn0uJHttaW5vcn0pIE5PREUgVkVSU0lPTiBXSElDSCBJU04nVCBPRkZJQ0lBTExZIFNVUFBPUlRFRC4gUExFQVNFIFVQR1JBREUgVE8gTk9ERSBeMTguMTMuYCk7XG4gICAgLy8gS2lsbCB0aGUgcHJvY2VzcyBpZiBpdCBpc24ndCBnb2luZyB0byB3b3JrIGNvcnJlY3RseSBhbnl3YXlcbiAgICAvLyBJZiB3ZSd2ZSBnb3R0ZW4gdGhpcyBmYXIgd2Uga25vdyB3ZSBoYXZlIGEgTm9kZS5qcyBydW50aW1lIHNvIGV4aXQgaXMgZGVmaW5lZC4gT3ZlcnJpZGUgc3RkLWVudiB0eXBlLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MsIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtY2FsbFxuICAgIHByb2Nlc3MuZXhpdD8uKDEpO1xufVxuXG5mdW5jdGlvbiBpbnRlcm5hbENyZWF0ZUJ1aWxkZXIoaW5pdERlZiA9IHt9KSB7XG4gICAgY29uc3QgX2RlZiA9IHtcbiAgICAgICAgLy8gRGVmYXVsdCByb3V0ZXIgY29uZmlnXG4gICAgICAgIHJvdXRlckNvbmZpZzoge1xuICAgICAgICAgICAgaW1hZ2U6IHtcbiAgICAgICAgICAgICAgICBtYXhGaWxlU2l6ZTogXCI0TUJcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBpbnB1dFBhcnNlcjoge1xuICAgICAgICAgICAgcGFyc2U6ICgpPT51bmRlZmluZWQsXG4gICAgICAgICAgICBfaW5wdXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIF9vdXRwdXQ6IHVuZGVmaW5lZFxuICAgICAgICB9LFxuICAgICAgICBtaWRkbGV3YXJlOiAoKT0+KHt9KSxcbiAgICAgICAgb25VcGxvYWRFcnJvcjogKCk9Pih7fSksXG4gICAgICAgIGVycm9yRm9ybWF0dGVyOiBpbml0RGVmLmVycm9yRm9ybWF0dGVyID8/IGRlZmF1bHRFcnJvckZvcm1hdHRlcixcbiAgICAgICAgLy8gT3ZlcmxvYWQgd2l0aCBwcm9wZXJ0aWVzIHBhc3NlZCBpblxuICAgICAgICAuLi5pbml0RGVmXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBpbnB1dCAodXNlclBhcnNlcikge1xuICAgICAgICAgICAgcmV0dXJuIGludGVybmFsQ3JlYXRlQnVpbGRlcih7XG4gICAgICAgICAgICAgICAgLi4uX2RlZixcbiAgICAgICAgICAgICAgICBpbnB1dFBhcnNlcjogdXNlclBhcnNlclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG1pZGRsZXdhcmUgKHVzZXJNaWRkbGV3YXJlKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxDcmVhdGVCdWlsZGVyKHtcbiAgICAgICAgICAgICAgICAuLi5fZGVmLFxuICAgICAgICAgICAgICAgIG1pZGRsZXdhcmU6IHVzZXJNaWRkbGV3YXJlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25VcGxvYWRDb21wbGV0ZSAodXNlclVwbG9hZENvbXBsZXRlKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIF9kZWYsXG4gICAgICAgICAgICAgICAgcmVzb2x2ZXI6IHVzZXJVcGxvYWRDb21wbGV0ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgb25VcGxvYWRFcnJvciAodXNlck9uVXBsb2FkRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbENyZWF0ZUJ1aWxkZXIoe1xuICAgICAgICAgICAgICAgIC4uLl9kZWYsXG4gICAgICAgICAgICAgICAgb25VcGxvYWRFcnJvcjogdXNlck9uVXBsb2FkRXJyb3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUJ1aWxkZXIob3B0cykge1xuICAgIHJldHVybiAoaW5wdXQpPT57XG4gICAgICAgIHJldHVybiBpbnRlcm5hbENyZWF0ZUJ1aWxkZXIoe1xuICAgICAgICAgICAgcm91dGVyQ29uZmlnOiBpbnB1dCxcbiAgICAgICAgICAgIC4uLm9wdHNcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cblxuY29uc3QgbWF5YmVQYXJzZVJlc3BvbnNlWE1MID0gKG1heWJlWG1sKT0+e1xuICAgIGNvbnN0IGNvZGVNYXRjaCA9IG1heWJlWG1sLm1hdGNoKC88Q29kZT4oLio/KTxcXC9Db2RlPi9zKTtcbiAgICBjb25zdCBtZXNzYWdlTWF0Y2ggPSBtYXliZVhtbC5tYXRjaCgvPE1lc3NhZ2U+KC4qPyk8XFwvTWVzc2FnZT4vcyk7XG4gICAgY29uc3QgY29kZSA9IGNvZGVNYXRjaD8uWzFdO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBtZXNzYWdlTWF0Y2g/LlsxXTtcbiAgICBpZiAoIWNvZGUgfHwgIW1lc3NhZ2UpIHJldHVybiBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvZGU6IHMzQ29kZVRvVXBsb2FkVGhpbmdDb2RlW2NvZGVdID8/IERFRkFVTFRfRVJST1JfQ09ERSxcbiAgICAgICAgbWVzc2FnZVxuICAgIH07XG59O1xuLyoqXG4gKiBNYXAgUzMgZXJyb3IgY29kZXMgdG8gVXBsb2FkVGhpbmcgZXJyb3IgY29kZXNcbiAqXG4gKiBUaGlzIGlzIGEgc3Vic2V0IG9mIHRoZSBTMyBlcnJvciBjb2RlcywgYmFzZWQgb24gd2hhdCBzZWVtZWQgbW9zdCBsaWtlbHkgdG9cbiAqIG9jY3VyIGluIHVwbG9hZHRoaW5nLiBGb3IgYSBmdWxsIGxpc3Qgb2YgUzMgZXJyb3IgY29kZXMsIHNlZTpcbiAqIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9BbWF6b25TMy9sYXRlc3QvQVBJL0Vycm9yUmVzcG9uc2VzLmh0bWxcbiAqLyBjb25zdCBERUZBVUxUX0VSUk9SX0NPREUgPSBcIlVQTE9BRF9GQUlMRURcIjtcbmNvbnN0IHMzQ29kZVRvVXBsb2FkVGhpbmdDb2RlID0ge1xuICAgIEFjY2Vzc0RlbmllZDogXCJGT1JCSURERU5cIixcbiAgICBFbnRpdHlUb29TbWFsbDogXCJUT09fU01BTExcIixcbiAgICBFbnRpdHlUb29MYXJnZTogXCJUT09fTEFSR0VcIixcbiAgICBFeHBpcmVkVG9rZW46IFwiRk9SQklEREVOXCIsXG4gICAgSW5jb3JyZWN0TnVtYmVyT2ZGaWxlc0luUG9zdFJlcXVlc3Q6IFwiVE9PX01BTllfRklMRVNcIixcbiAgICBJbnRlcm5hbEVycm9yOiBcIklOVEVSTkFMX1NFUlZFUl9FUlJPUlwiLFxuICAgIEtleVRvb0xvbmdFcnJvcjogXCJLRVlfVE9PX0xPTkdcIixcbiAgICBNYXhNZXNzYWdlTGVuZ3RoRXhjZWVkZWQ6IFwiVE9PX0xBUkdFXCJcbn07XG5cbi8qKlxuICogVXNlZCBieSBzZXJ2ZXIgdXBsb2FkcyB3aGVyZSBwcm9ncmVzcyBpcyBub3QgbmVlZGVkLlxuICogVXNlcyBub3JtYWwgZmV0Y2ggQVBJLlxuICovIGFzeW5jIGZ1bmN0aW9uIHVwbG9hZFBhcnQob3B0cywgcmV0cnlDb3VudCA9IDApIHtcbiAgICBjb25zdCBzM1JlcyA9IGF3YWl0IG9wdHMuZmV0Y2gob3B0cy51cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgICBib2R5OiBvcHRzLmNodW5rLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBvcHRzLmNvbnRlbnRUeXBlLFxuICAgICAgICAgICAgXCJDb250ZW50LURpc3Bvc2l0aW9uXCI6IGNvbnRlbnREaXNwb3NpdGlvbihvcHRzLmNvbnRlbnREaXNwb3NpdGlvbiwgb3B0cy5maWxlTmFtZSlcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzM1Jlcy5vaykge1xuICAgICAgICBjb25zdCBldGFnID0gczNSZXMuaGVhZGVycy5nZXQoXCJFdGFnXCIpO1xuICAgICAgICBpZiAoIWV0YWcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIlVQTE9BRF9GQUlMRURcIixcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIk1pc3NpbmcgRXRhZyBoZWFkZXIgZnJvbSB1cGxvYWRlZCBwYXJ0XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBldGFnLnJlcGxhY2UoL1wiL2csIFwiXCIpO1xuICAgIH1cbiAgICBpZiAocmV0cnlDb3VudCA8IG9wdHMubWF4UmV0cmllcykge1xuICAgICAgICAvLyBSZXRyeSBhZnRlciBleHBvbmVudGlhbCBiYWNrb2ZmXG4gICAgICAgIGNvbnN0IGRlbGF5ID0gMiAqKiByZXRyeUNvdW50ICogMTAwMDtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHIpPT5zZXRUaW1lb3V0KHIsIGRlbGF5KSk7XG4gICAgICAgIHJldHVybiB1cGxvYWRQYXJ0KG9wdHMsIHJldHJ5Q291bnQrKyk7XG4gICAgfVxuICAgIC8vIE1heCByZXRyaWVzIGV4Y2VlZGVkLCB0ZWxsIFVUIHNlcnZlciB0aGF0IHVwbG9hZCBmYWlsZWRcbiAgICBhd2FpdCBvcHRzLmZldGNoKGdlbmVyYXRlVXBsb2FkVGhpbmdVUkwoXCIvYXBpL2ZhaWx1cmVDYWxsYmFja1wiKSwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBmaWxlS2V5OiBvcHRzLmtleVxuICAgICAgICB9KSxcbiAgICAgICAgaGVhZGVyczogb3B0cy51dFJlcXVlc3RIZWFkZXJzXG4gICAgfSk7XG4gICAgY29uc3QgdGV4dCA9IGF3YWl0IHMzUmVzLnRleHQoKTtcbiAgICBjb25zdCBwYXJzZWQgPSBtYXliZVBhcnNlUmVzcG9uc2VYTUwodGV4dCk7XG4gICAgaWYgKHBhcnNlZD8ubWVzc2FnZSkge1xuICAgICAgICB0aHJvdyBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICBjb2RlOiBcIlVQTE9BRF9GQUlMRURcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IHBhcnNlZC5tZXNzYWdlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgIGNvZGU6IFwiVVBMT0FEX0ZBSUxFRFwiLFxuICAgICAgICBtZXNzYWdlOiBcIkZhaWxlZCB0byB1cGxvYWQgZmlsZSB0byBzdG9yYWdlIHByb3ZpZGVyXCIsXG4gICAgICAgIGNhdXNlOiBzM1Jlc1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBndWFyZFNlcnZlck9ubHkoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICAgICAgY29kZTogXCJJTlRFUk5BTF9TRVJWRVJfRVJST1JcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiVGhlIGB1dGFwaWAgY2FuIG9ubHkgYmUgdXNlZCBvbiB0aGUgc2VydmVyLlwiXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEFwaUtleU9yVGhyb3coYXBpS2V5KSB7XG4gICAgaWYgKGFwaUtleSkgcmV0dXJuIGFwaUtleTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuVVBMT0FEVEhJTkdfU0VDUkVUKSByZXR1cm4gcHJvY2Vzcy5lbnYuVVBMT0FEVEhJTkdfU0VDUkVUO1xuICAgIHRocm93IG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgY29kZTogXCJNSVNTSU5HX0VOVlwiLFxuICAgICAgICBtZXNzYWdlOiBcIk1pc3NpbmcgYFVQTE9BRFRISU5HX1NFQ1JFVGAgZW52IHZhcmlhYmxlLlwiXG4gICAgfSk7XG59XG5jb25zdCB1cGxvYWRGaWxlc0ludGVybmFsID0gYXN5bmMgKGRhdGEsIG9wdHMpPT57XG4gICAgLy8gUmVxdWVzdCBwcmVzaWduZWQgVVJMcyBmb3IgZWFjaCBmaWxlXG4gICAgY29uc3QgZmlsZURhdGEgPSBkYXRhLmZpbGVzLm1hcCgoZmlsZSk9Pih7XG4gICAgICAgICAgICBuYW1lOiBmaWxlLm5hbWUgPz8gXCJ1bm5hbWVkLWJsb2JcIixcbiAgICAgICAgICAgIHR5cGU6IGZpbGUudHlwZSxcbiAgICAgICAgICAgIHNpemU6IGZpbGUuc2l6ZSxcbiAgICAgICAgICAgIC4uLlwiY3VzdG9tSWRcIiBpbiBmaWxlID8ge1xuICAgICAgICAgICAgICAgIGN1c3RvbUlkOiBmaWxlLmN1c3RvbUlkXG4gICAgICAgICAgICB9IDoge31cbiAgICAgICAgfSkpO1xuICAgIGxvZ2dlci5kZWJ1ZyhcIkdldHRpbmcgcHJlc2lnbmVkIFVSTHMgZm9yIGZpbGVzXCIsIGZpbGVEYXRhKTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBvcHRzLmZldGNoKGdlbmVyYXRlVXBsb2FkVGhpbmdVUkwoXCIvYXBpL3VwbG9hZEZpbGVzXCIpLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IG9wdHMudXRSZXF1ZXN0SGVhZGVycyxcbiAgICAgICAgY2FjaGU6IFwibm8tc3RvcmVcIixcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgZmlsZXM6IGZpbGVEYXRhLFxuICAgICAgICAgICAgbWV0YWRhdGE6IGRhdGEubWV0YWRhdGEsXG4gICAgICAgICAgICBjb250ZW50RGlzcG9zaXRpb246IGRhdGEuY29udGVudERpc3Bvc2l0aW9uLFxuICAgICAgICAgICAgYWNsOiBkYXRhLmFjbFxuICAgICAgICB9KVxuICAgIH0pO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gYXdhaXQgVXBsb2FkVGhpbmdFcnJvci5mcm9tUmVzcG9uc2UocmVzKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKFwiRmFpbGVkIGdldHRpbmcgcHJlc2lnbmVkIFVSTHM6XCIsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IGpzb24gPSBhd2FpdCByZXMuanNvbigpO1xuICAgIGxvZ2dlci5kZWJ1ZyhcIkdvdCBwcmVzaWduZWQgVVJMczpcIiwganNvbi5kYXRhKTtcbiAgICBsb2dnZXIuZGVidWcoXCJTdGFydGluZyB1cGxvYWRzLi4uXCIpO1xuICAgIC8vIFVwbG9hZCBlYWNoIGZpbGUgdG8gUzMgaW4gY2h1bmtzIHVzaW5nIG11bHRpLXBhcnQgdXBsb2Fkc1xuICAgIGNvbnN0IHVwbG9hZHMgPSBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQoZGF0YS5maWxlcy5tYXAoYXN5bmMgKGZpbGUsIGkpPT57XG4gICAgICAgIGNvbnN0IHByZXNpZ25lZCA9IGpzb24uZGF0YVtpXTtcbiAgICAgICAgaWYgKCFwcmVzaWduZWQpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIkZhaWxlZCB0byBnZW5lcmF0ZSBwcmVzaWduZWQgVVJMIGZvciBmaWxlOlwiLCBmaWxlLCBwcmVzaWduZWQpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICAgICAgICAgIGNvZGU6IFwiVVJMX0dFTkVSQVRJT05fRkFJTEVEXCIsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCJGYWlsZWQgdG8gZ2VuZXJhdGUgcHJlc2lnbmVkIFVSTFwiLFxuICAgICAgICAgICAgICAgIGNhdXNlOiBKU09OLnN0cmluZ2lmeShwcmVzaWduZWQpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJ1cmxzXCIgaW4gcHJlc2lnbmVkKSB7XG4gICAgICAgICAgICBhd2FpdCB1cGxvYWRNdWx0aXBhcnQoZmlsZSwgcHJlc2lnbmVkLCB7XG4gICAgICAgICAgICAgICAgLi4ub3B0c1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCB1cGxvYWRQcmVzaWduZWRQb3N0KGZpbGUsIHByZXNpZ25lZCwge1xuICAgICAgICAgICAgICAgIC4uLm9wdHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBvbGwgZm9yIGZpbGUgdG8gYmUgYXZhaWxhYmxlXG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcIlBvbGxpbmcgZm9yIGZpbGUgZGF0YS4uLlwiKTtcbiAgICAgICAgYXdhaXQgcG9sbEZvckZpbGVEYXRhKHtcbiAgICAgICAgICAgIHVybDogZ2VuZXJhdGVVcGxvYWRUaGluZ1VSTChgL2FwaS9wb2xsVXBsb2FkLyR7cHJlc2lnbmVkLmtleX1gKSxcbiAgICAgICAgICAgIGFwaUtleTogb3B0cy51dFJlcXVlc3RIZWFkZXJzW1wieC11cGxvYWR0aGluZy1hcGkta2V5XCJdLFxuICAgICAgICAgICAgc2RrVmVyc2lvbjogdmVyc2lvbixcbiAgICAgICAgICAgIGZldGNoOiBvcHRzLmZldGNoXG4gICAgICAgIH0pO1xuICAgICAgICBsb2dnZXIuZGVidWcoXCJQb2xsaW5nIGNvbXBsZXRlLlwiKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtleTogcHJlc2lnbmVkLmtleSxcbiAgICAgICAgICAgIHVybDogcHJlc2lnbmVkLmZpbGVVcmwsXG4gICAgICAgICAgICBuYW1lOiBmaWxlLm5hbWUsXG4gICAgICAgICAgICBzaXplOiBmaWxlLnNpemUsXG4gICAgICAgICAgICB0eXBlOiBmaWxlLnR5cGUsXG4gICAgICAgICAgICBjdXN0b21JZDogXCJjdXN0b21JZFwiIGluIGZpbGUgPyBmaWxlLmN1c3RvbUlkID8/IG51bGwgOiBudWxsXG4gICAgICAgIH07XG4gICAgfSkpO1xuICAgIGxvZ2dlci5kZWJ1ZyhcIkFsbCB1cGxvYWRzIGNvbXBsZXRlLCBhZ2dyZWdhdGluZyByZXN1bHRzLi4uXCIpO1xuICAgIHJldHVybiB1cGxvYWRzLm1hcCgodXBsb2FkKT0+e1xuICAgICAgICBpZiAodXBsb2FkLnN0YXR1cyA9PT0gXCJmdWxmaWxsZWRcIikge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHVwbG9hZC52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBvbmx5IHRocm93IFVwbG9hZFRoaW5nRXJyb3JzLCBzbyB0aGlzIGlzIHNhZmVcbiAgICAgICAgY29uc3QgcmVhc29uID0gdXBsb2FkLnJlYXNvbjtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBVcGxvYWRUaGluZ0Vycm9yLnRvT2JqZWN0KHJlYXNvbik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgfTtcbiAgICB9KTtcbn07XG5hc3luYyBmdW5jdGlvbiB1cGxvYWRNdWx0aXBhcnQoZmlsZSwgcHJlc2lnbmVkLCBvcHRzKSB7XG4gICAgbG9nZ2VyLmRlYnVnKFwiVXBsb2FkaW5nIGZpbGVcIiwgZmlsZS5uYW1lLCBcIndpdGhcIiwgcHJlc2lnbmVkLnVybHMubGVuZ3RoLCBcImNodW5rcyBvZiBzaXplXCIsIHByZXNpZ25lZC5jaHVua1NpemUsIFwiYnl0ZXMgZWFjaFwiKTtcbiAgICBjb25zdCBldGFncyA9IGF3YWl0IFByb21pc2UuYWxsKHByZXNpZ25lZC51cmxzLm1hcChhc3luYyAodXJsLCBpbmRleCk9PntcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gcHJlc2lnbmVkLmNodW5rU2l6ZSAqIGluZGV4O1xuICAgICAgICBjb25zdCBlbmQgPSBNYXRoLm1pbihvZmZzZXQgKyBwcmVzaWduZWQuY2h1bmtTaXplLCBmaWxlLnNpemUpO1xuICAgICAgICBjb25zdCBjaHVuayA9IGZpbGUuc2xpY2Uob2Zmc2V0LCBlbmQpO1xuICAgICAgICBjb25zdCBldGFnID0gYXdhaXQgdXBsb2FkUGFydCh7XG4gICAgICAgICAgICBmZXRjaDogb3B0cy5mZXRjaCxcbiAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgIGNodW5rOiBjaHVuayxcbiAgICAgICAgICAgIGNvbnRlbnREaXNwb3NpdGlvbjogcHJlc2lnbmVkLmNvbnRlbnREaXNwb3NpdGlvbixcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBmaWxlLnR5cGUsXG4gICAgICAgICAgICBmaWxlTmFtZTogZmlsZS5uYW1lLFxuICAgICAgICAgICAgbWF4UmV0cmllczogMTAsXG4gICAgICAgICAgICBrZXk6IHByZXNpZ25lZC5rZXksXG4gICAgICAgICAgICB1dFJlcXVlc3RIZWFkZXJzOiBvcHRzLnV0UmVxdWVzdEhlYWRlcnNcbiAgICAgICAgfSk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcIlBhcnRcIiwgaW5kZXggKyAxLCBcInVwbG9hZGVkIHN1Y2Nlc3NmdWxseTpcIiwgZXRhZyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0YWc6IGV0YWcsXG4gICAgICAgICAgICBwYXJ0TnVtYmVyOiBpbmRleCArIDFcbiAgICAgICAgfTtcbiAgICB9KSk7XG4gICAgbG9nZ2VyLmRlYnVnKFwiRmlsZVwiLCBmaWxlLm5hbWUsIFwidXBsb2FkZWQgc3VjY2Vzc2Z1bGx5LiBOb3RpZnlpbmcgVXBsb2FkVGhpbmcgdG8gY29tcGxldGUgbXVsdGlwYXJ0IHVwbG9hZC5cIik7XG4gICAgLy8gQ29tcGxldGUgbXVsdGlwYXJ0IHVwbG9hZFxuICAgIGNvbnN0IGNvbXBsZXRpb25SZXMgPSBhd2FpdCBvcHRzLmZldGNoKGdlbmVyYXRlVXBsb2FkVGhpbmdVUkwoXCIvYXBpL2NvbXBsZXRlTXVsdGlwYXJ0XCIpLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIGZpbGVLZXk6IHByZXNpZ25lZC5rZXksXG4gICAgICAgICAgICB1cGxvYWRJZDogcHJlc2lnbmVkLnVwbG9hZElkLFxuICAgICAgICAgICAgZXRhZ3NcbiAgICAgICAgfSksXG4gICAgICAgIGhlYWRlcnM6IG9wdHMudXRSZXF1ZXN0SGVhZGVyc1xuICAgIH0pO1xuICAgIGxvZ2dlci5kZWJ1ZyhcIlVwbG9hZFRoaW5nIHJlc3BvbnNlZCB3aXRoIHN0YXR1czpcIiwgY29tcGxldGlvblJlcy5zdGF0dXMpO1xufVxuYXN5bmMgZnVuY3Rpb24gdXBsb2FkUHJlc2lnbmVkUG9zdChmaWxlLCBwcmVzaWduZWQsIG9wdHMpIHtcbiAgICBsb2dnZXIuZGVidWcoXCJVcGxvYWRpbmcgZmlsZVwiLCBmaWxlLm5hbWUsIFwidXNpbmcgcHJlc2lnbmVkIFBPU1QgVVJMXCIpO1xuICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgT2JqZWN0LmVudHJpZXMocHJlc2lnbmVkLmZpZWxkcykuZm9yRWFjaCgoW2ssIHZdKT0+Zm9ybURhdGEuYXBwZW5kKGssIHYpKTtcbiAgICBmb3JtRGF0YS5hcHBlbmQoXCJmaWxlXCIsIGZpbGUpOyAvLyBGaWxlIGRhdGEgKipNVVNUIEdPIExBU1QqKlxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IG9wdHMuZmV0Y2gocHJlc2lnbmVkLnVybCwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBib2R5OiBmb3JtRGF0YSxcbiAgICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnMoe1xuICAgICAgICAgICAgQWNjZXB0OiBcImFwcGxpY2F0aW9uL3htbFwiXG4gICAgICAgIH0pXG4gICAgfSk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICAgIGxvZ2dlci5lcnJvcihcIkZhaWxlZCB0byB1cGxvYWQgZmlsZTpcIiwgdGV4dCk7XG4gICAgICAgIHRocm93IG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgIGNvZGU6IFwiVVBMT0FEX0ZBSUxFRFwiLFxuICAgICAgICAgICAgbWVzc2FnZTogXCJGYWlsZWQgdG8gdXBsb2FkIGZpbGVcIixcbiAgICAgICAgICAgIGNhdXNlOiB0ZXh0XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsb2dnZXIuZGVidWcoXCJGaWxlXCIsIGZpbGUubmFtZSwgXCJ1cGxvYWRlZCBzdWNjZXNzZnVsbHlcIik7XG59XG5mdW5jdGlvbiBwYXJzZVRpbWVUb1NlY29uZHModGltZSkge1xuICAgIGNvbnN0IG1hdGNoID0gdGltZS50b1N0cmluZygpLnNwbGl0KC8oXFxkKykvKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgY29uc3QgbnVtID0gTnVtYmVyKG1hdGNoWzBdKTtcbiAgICBjb25zdCB1bml0ID0gKG1hdGNoWzFdID8/IFwic1wiKS50cmltKCkuc2xpY2UoMCwgMSk7XG4gICAgY29uc3QgbXVsdGlwbGllciA9IHtcbiAgICAgICAgczogMSxcbiAgICAgICAgbTogNjAsXG4gICAgICAgIGg6IDM2MDAsXG4gICAgICAgIGQ6IDg2NDAwXG4gICAgfVt1bml0XTtcbiAgICByZXR1cm4gbnVtICogbXVsdGlwbGllcjtcbn1cblxuLyoqXG4gKiBFeHRlbnNpb24gb2YgdGhlIEJsb2IgY2xhc3MgdGhhdCBzaW1wbGlmaWVzIHNldHRpbmcgdGhlIGBuYW1lYCBhbmQgYGN1c3RvbUlkYCBwcm9wZXJ0aWVzLFxuICogc2ltaWxhciB0byB0aGUgYnVpbHQtaW4gRmlsZSBjbGFzcyBmcm9tIE5vZGUgPiAyMC5cbiAqLyBjbGFzcyBVVEZpbGUgZXh0ZW5kcyBCbG9iIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJ0cywgbmFtZSwgb3B0aW9ucyl7XG4gICAgICAgIGNvbnN0IG9wdGlvbnNXaXRoRGVmYXVsdHMgPSB7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgdHlwZTogb3B0aW9ucz8udHlwZSA/PyAobG9va3VwKG5hbWUpIHx8IHVuZGVmaW5lZCksXG4gICAgICAgICAgICBsYXN0TW9kaWZpZWQ6IG9wdGlvbnM/Lmxhc3RNb2RpZmllZCA/PyBEYXRlLm5vdygpXG4gICAgICAgIH07XG4gICAgICAgIHN1cGVyKHBhcnRzLCBvcHRpb25zV2l0aERlZmF1bHRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5jdXN0b21JZCA9IG9wdGlvbnNXaXRoRGVmYXVsdHMuY3VzdG9tSWQ7XG4gICAgICAgIHRoaXMubGFzdE1vZGlmaWVkID0gb3B0aW9uc1dpdGhEZWZhdWx0cy5sYXN0TW9kaWZpZWQ7XG4gICAgfVxufVxuY2xhc3MgVVRBcGkge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpe1xuICAgICAgICAvKipcbiAgICogUmVxdWVzdCB0byBkZWxldGUgZmlsZXMgZnJvbSBVcGxvYWRUaGluZyBzdG9yYWdlLlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IHN0cmluZ1tdfSBmaWxlS2V5c1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBhd2FpdCBkZWxldGVGaWxlcyhcIjJlMGZkYjY0LTk5NTctNDI2Mi04ZTQ1LWYzNzJiYTkwM2FjOF9pbWFnZS5qcGdcIik7XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGF3YWl0IGRlbGV0ZUZpbGVzKFtcIjJlMGZkYjY0LTk5NTctNDI2Mi04ZTQ1LWYzNzJiYTkwM2FjOF9pbWFnZS5qcGdcIixcIjE2NDkzNTNiLTA0ZWEtNDhhMi05ZGI3LTMxZGU3ZjU2MmM4ZF9pbWFnZTIuanBnXCJdKVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBhd2FpdCBkZWxldGVGaWxlcyhcIm15Q3VzdG9tSWRlbnRpZmllclwiLCB7IGtleVR5cGU6IFwiY3VzdG9tSWRcIiB9KVxuICAgKi8gdGhpcy5kZWxldGVGaWxlcyA9IGFzeW5jIChrZXlzLCBvcHRzKT0+e1xuICAgICAgICAgICAgZ3VhcmRTZXJ2ZXJPbmx5KCk7XG4gICAgICAgICAgICBjb25zdCB7IGtleVR5cGUgPSB0aGlzLmRlZmF1bHRLZXlUeXBlIH0gPSBvcHRzID8/IHt9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdFVwbG9hZFRoaW5nKFwiL2FwaS9kZWxldGVGaWxlXCIsIGtleVR5cGUgPT09IFwiZmlsZUtleVwiID8ge1xuICAgICAgICAgICAgICAgIGZpbGVLZXlzOiBhc0FycmF5KGtleXMpXG4gICAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgICAgIGN1c3RvbUlkczogYXNBcnJheShrZXlzKVxuICAgICAgICAgICAgfSwgXCJBbiB1bmtub3duIGVycm9yIG9jY3VycmVkIHdoaWxlIGRlbGV0aW5nIGZpbGVzLlwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAqIFJlcXVlc3QgZmlsZSBVUkxzIGZyb20gVXBsb2FkVGhpbmcgc3RvcmFnZS5cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBzdHJpbmdbXX0gZmlsZUtleXNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgZGF0YSA9IGF3YWl0IGdldEZpbGVVcmxzKFwiMmUwZmRiNjQtOTk1Ny00MjYyLThlNDUtZjM3MmJhOTAzYWM4X2ltYWdlLmpwZ1wiKTtcbiAgICogY29uc29sZS5sb2coZGF0YSk7IC8vIFt7a2V5OiBcIjJlMGZkYjY0LTk5NTctNDI2Mi04ZTQ1LWYzNzJiYTkwM2FjOF9pbWFnZS5qcGdcIiwgdXJsOiBcImh0dHBzOi8vdXBsb2FkdGhpbmcuY29tL2YvMmUwZmRiNjQtOTk1Ny00MjYyLThlNDUtZjM3MmJhOTAzYWM4X2ltYWdlLmpwZ1wifV1cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgZGF0YSA9IGF3YWl0IGdldEZpbGVVcmxzKFtcIjJlMGZkYjY0LTk5NTctNDI2Mi04ZTQ1LWYzNzJiYTkwM2FjOF9pbWFnZS5qcGdcIixcIjE2NDkzNTNiLTA0ZWEtNDhhMi05ZGI3LTMxZGU3ZjU2MmM4ZF9pbWFnZTIuanBnXCJdKVxuICAgKiBjb25zb2xlLmxvZyhkYXRhKSAvLyBbe2tleTogXCIyZTBmZGI2NC05OTU3LTQyNjItOGU0NS1mMzcyYmE5MDNhYzhfaW1hZ2UuanBnXCIsIHVybDogXCJodHRwczovL3VwbG9hZHRoaW5nLmNvbS9mLzJlMGZkYjY0LTk5NTctNDI2Mi04ZTQ1LWYzNzJiYTkwM2FjOF9pbWFnZS5qcGdcIiB9LHtrZXk6IFwiMTY0OTM1M2ItMDRlYS00OGEyLTlkYjctMzFkZTdmNTYyYzhkX2ltYWdlMi5qcGdcIiwgdXJsOiBcImh0dHBzOi8vdXBsb2FkdGhpbmcuY29tL2YvMTY0OTM1M2ItMDRlYS00OGEyLTlkYjctMzFkZTdmNTYyYzhkX2ltYWdlMi5qcGdcIn1dXG4gICAqLyB0aGlzLmdldEZpbGVVcmxzID0gYXN5bmMgKGtleXMsIG9wdHMpPT57XG4gICAgICAgICAgICBndWFyZFNlcnZlck9ubHkoKTtcbiAgICAgICAgICAgIGNvbnN0IHsga2V5VHlwZSA9IHRoaXMuZGVmYXVsdEtleVR5cGUgfSA9IG9wdHMgPz8ge307XG4gICAgICAgICAgICBjb25zdCBqc29uID0gYXdhaXQgdGhpcy5yZXF1ZXN0VXBsb2FkVGhpbmcoXCIvYXBpL2dldEZpbGVVcmxcIiwga2V5VHlwZSA9PT0gXCJmaWxlS2V5XCIgPyB7XG4gICAgICAgICAgICAgICAgZmlsZUtleXM6IGFzQXJyYXkoa2V5cylcbiAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgICAgY3VzdG9tSWRzOiBhc0FycmF5KGtleXMpXG4gICAgICAgICAgICB9LCBcIkFuIHVua25vd24gZXJyb3Igb2NjdXJyZWQgd2hpbGUgcmV0cmlldmluZyBmaWxlIFVSTHMuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGpzb24uZGF0YTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAqIFJlcXVlc3QgZmlsZSBsaXN0IGZyb20gVXBsb2FkVGhpbmcgc3RvcmFnZS5cbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdHNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wdHMubGltaXQgVGhlIG1heGltdW0gbnVtYmVyIG9mIGZpbGVzIHRvIHJldHVyblxuICAgKiBAcGFyYW0ge251bWJlcn0gb3B0cy5vZmZzZXQgVGhlIG51bWJlciBvZiBmaWxlcyB0byBza2lwXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IGRhdGEgPSBhd2FpdCBsaXN0RmlsZXMoeyBsaW1pdDogMSB9KTtcbiAgICogY29uc29sZS5sb2coZGF0YSk7IC8vIHsga2V5OiBcIjJlMGZkYjY0LTk5NTctNDI2Mi04ZTQ1LWYzNzJiYTkwM2FjOF9pbWFnZS5qcGdcIiwgaWQ6IFwiMmUwZmRiNjQtOTk1Ny00MjYyLThlNDUtZjM3MmJhOTAzYWM4XCIgfVxuICAgKi8gdGhpcy5saXN0RmlsZXMgPSBhc3luYyAob3B0cyk9PntcbiAgICAgICAgICAgIGd1YXJkU2VydmVyT25seSgpO1xuICAgICAgICAgICAgY29uc3QganNvbiA9IGF3YWl0IHRoaXMucmVxdWVzdFVwbG9hZFRoaW5nKFwiL2FwaS9saXN0RmlsZXNcIiwge1xuICAgICAgICAgICAgICAgIC4uLm9wdHNcbiAgICAgICAgICAgIH0sIFwiQW4gdW5rbm93biBlcnJvciBvY2N1cnJlZCB3aGlsZSBsaXN0aW5nIGZpbGVzLlwiKTtcbiAgICAgICAgICAgIHJldHVybiBqc29uLmZpbGVzO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJlbmFtZUZpbGVzID0gYXN5bmMgKHVwZGF0ZXMpPT57XG4gICAgICAgICAgICBndWFyZFNlcnZlck9ubHkoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RVcGxvYWRUaGluZyhcIi9hcGkvcmVuYW1lRmlsZXNcIiwge1xuICAgICAgICAgICAgICAgIHVwZGF0ZXM6IGFzQXJyYXkodXBkYXRlcylcbiAgICAgICAgICAgIH0sIFwiQW4gdW5rbm93biBlcnJvciBvY2N1cnJlZCB3aGlsZSByZW5hbWluZyBmaWxlcy5cIik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIHJlbmFtZUZpbGVzfSBpbnN0ZWFkLiAqLyB0aGlzLnJlbmFtZUZpbGUgPSB0aGlzLnJlbmFtZUZpbGVzO1xuICAgICAgICB0aGlzLmdldFVzYWdlSW5mbyA9IGFzeW5jICgpPT57XG4gICAgICAgICAgICBndWFyZFNlcnZlck9ubHkoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RVcGxvYWRUaGluZyhcIi9hcGkvZ2V0VXNhZ2VJbmZvXCIsIHt9LCBcIkFuIHVua25vd24gZXJyb3Igb2NjdXJyZWQgd2hpbGUgZ2V0dGluZyB1c2FnZSBpbmZvLlwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIFJlcXVlc3QgYSBwcmVzaWduZWQgdXJsIGZvciBhIHByaXZhdGUgZmlsZShzKSAqLyB0aGlzLmdldFNpZ25lZFVSTCA9IGFzeW5jIChrZXksIG9wdHMpPT57XG4gICAgICAgICAgICBndWFyZFNlcnZlck9ubHkoKTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGlyZXNJbiA9IG9wdHM/LmV4cGlyZXNJbiA/IHBhcnNlVGltZVRvU2Vjb25kcyhvcHRzLmV4cGlyZXNJbikgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCB7IGtleVR5cGUgPSB0aGlzLmRlZmF1bHRLZXlUeXBlIH0gPSBvcHRzID8/IHt9O1xuICAgICAgICAgICAgaWYgKG9wdHM/LmV4cGlyZXNJbiAmJiBpc05hTihleHBpcmVzSW4pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIkJBRF9SRVFVRVNUXCIsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiZXhwaXJlc0luIG11c3QgYmUgYSB2YWxpZCB0aW1lIHN0cmluZywgZm9yIGV4YW1wbGUgJzFkJywgJzIgZGF5cycsIG9yIGEgbnVtYmVyIG9mIHNlY29uZHMuXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHBpcmVzSW4gJiYgZXhwaXJlc0luID4gODY0MDAgKiA3KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIkJBRF9SRVFVRVNUXCIsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiZXhwaXJlc0luIG11c3QgYmUgbGVzcyB0aGFuIDcgZGF5cyAoNjA0ODAwIHNlY29uZHMpLlwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBqc29uID0gYXdhaXQgdGhpcy5yZXF1ZXN0VXBsb2FkVGhpbmcoXCIvYXBpL3JlcXVlc3RGaWxlQWNjZXNzXCIsIGtleVR5cGUgPT09IFwiZmlsZUtleVwiID8ge1xuICAgICAgICAgICAgICAgIGZpbGVLZXk6IGtleSxcbiAgICAgICAgICAgICAgICBleHBpcmVzSW5cbiAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgICAgY3VzdG9tSWQ6IGtleSxcbiAgICAgICAgICAgICAgICBleHBpcmVzSW5cbiAgICAgICAgICAgIH0sIFwiQW4gdW5rbm93biBlcnJvciBvY2N1cnJlZCB3aGlsZSByZXRyaWV2aW5nIHByZXNpZ25lZCBVUkxzLlwiKTtcbiAgICAgICAgICAgIHJldHVybiBqc29uLnVybDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5mZXRjaCA9IG9wdHM/LmZldGNoID8/IGdsb2JhbFRoaXMuZmV0Y2g7XG4gICAgICAgIHRoaXMuYXBpS2V5ID0gb3B0cz8uYXBpS2V5ID8/IHByb2Nlc3MuZW52LlVQTE9BRFRISU5HX1NFQ1JFVDtcbiAgICAgICAgdGhpcy5kZWZhdWx0SGVhZGVycyA9IHtcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgXCJ4LXVwbG9hZHRoaW5nLWFwaS1rZXlcIjogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICBcIngtdXBsb2FkdGhpbmctdmVyc2lvblwiOiB2ZXJzaW9uLFxuICAgICAgICAgICAgXCJ4LXVwbG9hZHRoaW5nLWJlLWFkYXB0ZXJcIjogXCJzZXJ2ZXItc2RrXCJcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZWZhdWx0S2V5VHlwZSA9IG9wdHM/LmRlZmF1bHRLZXlUeXBlID8/IFwiZmlsZUtleVwiO1xuICAgICAgICBpbml0TG9nZ2VyKG9wdHM/LmxvZ0xldmVsKTtcbiAgICAgICAgLy8gQXNzZXJ0IHNvbWUgc3R1ZmZcbiAgICAgICAgZ3VhcmRTZXJ2ZXJPbmx5KCk7XG4gICAgICAgIGdldEFwaUtleU9yVGhyb3codGhpcy5hcGlLZXkpO1xuICAgICAgICBpZiAoIXRoaXMuYXBpS2V5Py5zdGFydHNXaXRoKFwic2tfXCIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICAgICAgY29kZTogXCJNSVNTSU5HX0VOVlwiLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiSW52YWxpZCBBUEkga2V5LiBBUEkga2V5cyBtdXN0IHN0YXJ0IHdpdGggYHNrX2AuXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGluY29tcGF0aWJsZU5vZGVHdWFyZCgpO1xuICAgIH1cbiAgICBhc3luYyByZXF1ZXN0VXBsb2FkVGhpbmcocGF0aG5hbWUsIGJvZHksIGZhbGxiYWNrRXJyb3JNZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IGdlbmVyYXRlVXBsb2FkVGhpbmdVUkwocGF0aG5hbWUpO1xuICAgICAgICBsb2dnZXIuZGVidWcoXCJSZXF1ZXN0aW5nIFVwbG9hZFRoaW5nOlwiLCB7XG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5kZWZhdWx0SGVhZGVyc1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5mZXRjaCh1cmwsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBjYWNoZTogXCJuby1zdG9yZVwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5kZWZhdWx0SGVhZGVycyxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpXG4gICAgICAgIH0pO1xuICAgICAgICBsb2dnZXIuZGVidWcoXCJVcGxvYWRUaGluZyByZXNwb25zZWQgd2l0aCBzdGF0dXM6XCIsIHJlcy5zdGF0dXMpO1xuICAgICAgICBjb25zdCBqc29uID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICAgICAgaWYgKCFyZXMub2sgfHwgXCJlcnJvclwiIGluIGpzb24pIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIkVycm9yOlwiLCBqc29uKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIklOVEVSTkFMX1NFUlZFUl9FUlJPUlwiLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiZXJyb3JcIiBpbiBqc29uICYmIHR5cGVvZiBqc29uLmVycm9yID09PSBcInN0cmluZ1wiID8ganNvbi5lcnJvciA6IGZhbGxiYWNrRXJyb3JNZXNzYWdlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuZGVidWcoXCJVcGxvYWRUaGluZyByZXNwb25zZTpcIiwganNvbik7XG4gICAgICAgIHJldHVybiBqc29uO1xuICAgIH1cbiAgICBhc3luYyB1cGxvYWRGaWxlcyhmaWxlcywgb3B0cykge1xuICAgICAgICBndWFyZFNlcnZlck9ubHkoKTtcbiAgICAgICAgY29uc3QgdXBsb2FkcyA9IGF3YWl0IHVwbG9hZEZpbGVzSW50ZXJuYWwoe1xuICAgICAgICAgICAgZmlsZXM6IGFzQXJyYXkoZmlsZXMpLFxuICAgICAgICAgICAgbWV0YWRhdGE6IG9wdHM/Lm1ldGFkYXRhID8/IHt9LFxuICAgICAgICAgICAgY29udGVudERpc3Bvc2l0aW9uOiBvcHRzPy5jb250ZW50RGlzcG9zaXRpb24gPz8gXCJpbmxpbmVcIixcbiAgICAgICAgICAgIGFjbDogb3B0cz8uYWNsXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGZldGNoOiB0aGlzLmZldGNoLFxuICAgICAgICAgICAgdXRSZXF1ZXN0SGVhZGVyczogdGhpcy5kZWZhdWx0SGVhZGVyc1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdXBsb2FkRmlsZVJlc3BvbnNlID0gQXJyYXkuaXNBcnJheShmaWxlcykgPyB1cGxvYWRzIDogdXBsb2Fkc1swXTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKFwiRmluaXNoZWQgdXBsb2FkaW5nOlwiLCB1cGxvYWRGaWxlUmVzcG9uc2UpO1xuICAgICAgICByZXR1cm4gdXBsb2FkRmlsZVJlc3BvbnNlO1xuICAgIH1cbiAgICBhc3luYyB1cGxvYWRGaWxlc0Zyb21VcmwodXJscywgb3B0cykge1xuICAgICAgICBndWFyZFNlcnZlck9ubHkoKTtcbiAgICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKFwibWV0YWRhdGFcIiwgSlNPTi5zdHJpbmdpZnkob3B0cz8ubWV0YWRhdGEgPz8ge30pKTtcbiAgICAgICAgY29uc3QgZG93bmxvYWRFcnJvcnMgPSB7fTtcbiAgICAgICAgY29uc3QgZmlsZXMgPSBhd2FpdCBQcm9taXNlLmFsbChhc0FycmF5KHVybHMpLm1hcChhc3luYyAoX3VybCwgaW5kZXgpPT57XG4gICAgICAgICAgICBsZXQgdXJsID0gaXNPYmplY3QoX3VybCkgPyBfdXJsLnVybCA6IF91cmw7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHVybCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIC8vIHNpbmNlIGRhdGF1cmxzIHdpbGwgcmVzdWx0IGluIG5hbWUgYmVpbmcgdG9vIGxvbmcsIHRlbGwgdGhlIHVzZXJcbiAgICAgICAgICAgICAgICAvLyB0byB1c2UgdXBsb2FkRmlsZXMgaW5zdGVhZC5cbiAgICAgICAgICAgICAgICBpZiAodXJsLnN0YXJ0c1dpdGgoXCJkYXRhOlwiKSkge1xuICAgICAgICAgICAgICAgICAgICBkb3dubG9hZEVycm9yc1tpbmRleF0gPSBVcGxvYWRUaGluZ0Vycm9yLnRvT2JqZWN0KG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiQkFEX1JFUVVFU1RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiUGxlYXNlIHVzZSB1cGxvYWRGaWxlcygpIGZvciBkYXRhIFVSTHMuIHVwbG9hZEZpbGVzRnJvbVVybCgpIGlzIGludGVuZGVkIGZvciB1c2Ugd2l0aCByZW1vdGUgVVJMcyBvbmx5LlwiXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdXJsID0gbmV3IFVSTCh1cmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBuYW1lID0gdXJsLnBhdGhuYW1lLnNwbGl0KFwiL1wiKS5wb3AoKSA/PyBcInVua25vd24tZmlsZW5hbWVcIiwgY3VzdG9tSWQgPSB1bmRlZmluZWQgfSA9IGlzT2JqZWN0KF91cmwpID8gX3VybCA6IHt9O1xuICAgICAgICAgICAgLy8gRG93bmxvYWQgdGhlIGZpbGUgb24gdGhlIHVzZXIncyBzZXJ2ZXIgdG8gYXZvaWQgZWdyZXNzIGNoYXJnZXNcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIkRvd25sb2FkaW5nIGZpbGU6XCIsIHVybCk7XG4gICAgICAgICAgICBjb25zdCBmaWxlUmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoKHVybCk7XG4gICAgICAgICAgICBpZiAoIWZpbGVSZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgIGRvd25sb2FkRXJyb3JzW2luZGV4XSA9IFVwbG9hZFRoaW5nRXJyb3IudG9PYmplY3QobmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIkJBRF9SRVFVRVNUXCIsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiRmFpbGVkIHRvIGRvd25sb2FkIHJlcXVlc3RlZCBmaWxlLlwiLFxuICAgICAgICAgICAgICAgICAgICBjYXVzZTogZmlsZVJlc3BvbnNlXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJGaW5pc2hlZCBkb3dubG9hZGluZyBmaWxlLiBSZWFkaW5nIGJsb2IuLi5cIik7XG4gICAgICAgICAgICBjb25zdCBibG9iID0gYXdhaXQgZmlsZVJlc3BvbnNlLmJsb2IoKTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIkZpbmlzaGVkIHJlYWRpbmcgYmxvYi5cIik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVURmlsZShbXG4gICAgICAgICAgICAgICAgYmxvYlxuICAgICAgICAgICAgXSwgbmFtZSwge1xuICAgICAgICAgICAgICAgIGN1c3RvbUlkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkpLnRoZW4oKGZpbGVzKT0+ZmlsZXMuZmlsdGVyKCh4KT0+eCAhPT0gdW5kZWZpbmVkKSk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcIlVwbG9hZGluZyBmaWxlczpcIiwgZmlsZXMpO1xuICAgICAgICBjb25zdCB1cGxvYWRzID0gYXdhaXQgdXBsb2FkRmlsZXNJbnRlcm5hbCh7XG4gICAgICAgICAgICBmaWxlcyxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBvcHRzPy5tZXRhZGF0YSA/PyB7fSxcbiAgICAgICAgICAgIGNvbnRlbnREaXNwb3NpdGlvbjogb3B0cz8uY29udGVudERpc3Bvc2l0aW9uID8/IFwiaW5saW5lXCIsXG4gICAgICAgICAgICBhY2w6IG9wdHM/LmFjbFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBmZXRjaDogdGhpcy5mZXRjaCxcbiAgICAgICAgICAgIHV0UmVxdWVzdEhlYWRlcnM6IHRoaXMuZGVmYXVsdEhlYWRlcnNcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBQdXQgaXQgYWxsIGJhY2sgdG9nZXRoZXIsIHByZXNlcnZlIHRoZSBvcmRlciBvZiBmaWxlcyAqLyBjb25zdCByZXNwb25zZXMgPSBhc0FycmF5KHVybHMpLm1hcCgoXywgaW5kZXgpPT57XG4gICAgICAgICAgICBpZiAoZG93bmxvYWRFcnJvcnNbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGRvd25sb2FkRXJyb3JzW2luZGV4XVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdXBsb2Fkcy5zaGlmdCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgLyoqIFJldHVybiBzaW5nbGUgb2JqZWN0IG9yIGFycmF5IGJhc2VkIG9uIGlucHV0IHVybHMgKi8gY29uc3QgdXBsb2FkRmlsZVJlc3BvbnNlID0gQXJyYXkuaXNBcnJheSh1cmxzKSA/IHJlc3BvbnNlcyA6IHJlc3BvbnNlc1swXTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKFwiRmluaXNoZWQgdXBsb2FkaW5nOlwiLCB1cGxvYWRGaWxlUmVzcG9uc2UpO1xuICAgICAgICByZXR1cm4gdXBsb2FkRmlsZVJlc3BvbnNlO1xuICAgIH1cbn1cblxuY29uc3QgY3JlYXRlVXBsb2FkdGhpbmcgPSAob3B0cyk9PmNyZWF0ZUJ1aWxkZXIob3B0cyk7XG4vKiogQGludGVybmFsICovIGNvbnN0IElOVEVSTkFMX0RPX05PVF9VU0VfY3JlYXRlUm91dGVIYW5kbGVyQ29yZSA9IChvcHRzLCBhZGFwdGVyKT0+e1xuICAgIGluaXRMb2dnZXIob3B0cy5jb25maWc/LmxvZ0xldmVsKTtcbiAgICBpbmNvbXBhdGlibGVOb2RlR3VhcmQoKTtcbiAgICBjb25zdCByZXF1ZXN0SGFuZGxlciA9IGJ1aWxkUmVxdWVzdEhhbmRsZXIob3B0cywgYWRhcHRlcik7XG4gICAgY29uc3QgZ2V0QnVpbGRQZXJtcyA9IGJ1aWxkUGVybWlzc2lvbnNJbmZvSGFuZGxlcihvcHRzKTtcbiAgICBjb25zdCBQT1NUID0gYXN5bmMgKHJlcXVlc3QpPT57XG4gICAgICAgIGNvbnN0IHJlcSA9IHJlcXVlc3QgaW5zdGFuY2VvZiBSZXF1ZXN0ID8gcmVxdWVzdCA6IHJlcXVlc3QucmVxdWVzdDtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0SGFuZGxlcih7XG4gICAgICAgICAgICByZXEsXG4gICAgICAgICAgICBtaWRkbGV3YXJlQXJnczoge1xuICAgICAgICAgICAgICAgIHJlcSxcbiAgICAgICAgICAgICAgICByZXM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBldmVudDogdW5kZWZpbmVkXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmVzcG9uc2UgaW5zdGFuY2VvZiBVcGxvYWRUaGluZ0Vycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKEpTT04uc3RyaW5naWZ5KGZvcm1hdEVycm9yKHJlc3BvbnNlLCBvcHRzLnJvdXRlcikpLCB7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiBnZXRTdGF0dXNDb2RlRnJvbUVycm9yKHJlc3BvbnNlKSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgIFwieC11cGxvYWR0aGluZy12ZXJzaW9uXCI6IHZlcnNpb25cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgICAgIC8vIFdlIG1lc3NlZCB1cCAtIHRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShcIkFuIHVua25vd24gZXJyb3Igb2NjdXJyZWRcIiwge1xuICAgICAgICAgICAgICAgIHN0YXR1czogNTAwLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJ4LXVwbG9hZHRoaW5nLXZlcnNpb25cIjogdmVyc2lvblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcyA9IG5ldyBSZXNwb25zZShKU09OLnN0cmluZ2lmeShyZXNwb25zZS5ib2R5KSwge1xuICAgICAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgXCJ4LXVwbG9hZHRoaW5nLXZlcnNpb25cIjogdmVyc2lvblxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtIHRoaXMgaXMgYSBjdXN0b20gcHJvcGVydHlcbiAgICAgICAgcmVzLmNsZWFudXAgPSByZXNwb25zZS5jbGVhbnVwO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgY29uc3QgR0VUID0gKHJlcXVlc3QpPT57XG4gICAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UoSlNPTi5zdHJpbmdpZnkoZ2V0QnVpbGRQZXJtcygpKSwge1xuICAgICAgICAgICAgc3RhdHVzOiAyMDAsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgXCJ4LXVwbG9hZHRoaW5nLXZlcnNpb25cIjogdmVyc2lvblxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIEdFVCxcbiAgICAgICAgUE9TVFxuICAgIH07XG59O1xuY29uc3QgY3JlYXRlUm91dGVIYW5kbGVyID0gKG9wdHMpPT5JTlRFUk5BTF9ET19OT1RfVVNFX2NyZWF0ZVJvdXRlSGFuZGxlckNvcmUob3B0cywgXCJzZXJ2ZXJcIik7XG5jb25zdCBleHRyYWN0Um91dGVyQ29uZmlnID0gKHJvdXRlcik9PmJ1aWxkUGVybWlzc2lvbnNJbmZvSGFuZGxlcih7XG4gICAgICAgIHJvdXRlclxuICAgIH0pKCk7XG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgY3JlYXRlUm91dGVIYW5kbGVyfSBpbnN0ZWFkXG4gKi8gY29uc3QgY3JlYXRlU2VydmVySGFuZGxlciA9IGNyZWF0ZVJvdXRlSGFuZGxlcjtcblxuZXhwb3J0IHsgSU5URVJOQUxfRE9fTk9UX1VTRV9jcmVhdGVSb3V0ZUhhbmRsZXJDb3JlLCBVVEFwaSwgVVRGaWxlLCBjcmVhdGVSb3V0ZUhhbmRsZXIsIGNyZWF0ZVNlcnZlckhhbmRsZXIsIGNyZWF0ZVVwbG9hZHRoaW5nLCBleHRyYWN0Um91dGVyQ29uZmlnIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/uploadthing/server/index.js\n");

/***/ })

};
;